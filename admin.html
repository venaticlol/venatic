<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Recon Spoofer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            background-image: 
                linear-gradient(rgba(42, 42, 42, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(42, 42, 42, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            background-position: 0 0, 0 0;
            color: #e5e5e5;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Re-enable text selection for input fields and textareas */
        input, textarea, [contenteditable="true"], .form-input, .admin-form-input {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(42, 42, 42, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(42, 42, 42, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            background-position: 0 0, 0 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Container */
        .admin-container {
            position: relative;
            z-index: 2;
            max-width: 1600px;
            margin: 0 auto;
            padding: 30px;
        }

        /* Header */
        .admin-header {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            padding: 25px 35px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .admin-header:hover {
            border-color: #2a2a2a;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
        }

        .admin-header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .admin-logo {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 800;
            transition: all 0.3s ease;
        }

        .admin-header:hover .admin-logo {
            border-color: #4a4a4a;
            transform: scale(1.05);
        }

        .admin-header-title {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #b0b0b0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .admin-header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .admin-btn {
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .admin-btn-primary {
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e5e5e5;
        }

        .admin-btn-primary:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
            border-color: #6a6a6a;
            background: #222222;
        }

        .admin-btn-danger {
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e5e5e5;
        }

        .admin-btn-danger:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
            border-color: #6a6a6a;
            background: #222222;
        }

        /* Tabs */
        .admin-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            background: #0a0a0a;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #1a1a1a;
            position: relative;
            z-index: 1;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #3a3a3a #0a0a0a;
        }

        .admin-tabs::-webkit-scrollbar {
            height: 8px;
        }

        .admin-tabs::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .admin-tabs::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 4px;
        }

        .admin-tabs::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        .admin-tab {
            flex: 0 0 auto;
            padding: 14px 24px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #888;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            white-space: nowrap;
        }

        .admin-tab.active {
            background: #1a1a1a;
            color: #e5e5e5;
            border: 1px solid #3a3a3a;
        }

        .admin-tab:hover:not(.active) {
            color: #e5e5e5;
            background: rgba(26, 26, 26, 0.5);
        }

        /* Content Cards */
        .admin-content-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .admin-content-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transition: left 0.6s;
        }

        .admin-content-card:hover::before {
            left: 100%;
        }

        .admin-content-card:hover {
            border-color: #2a2a2a;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
        }

        .admin-content-card h2 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #e5e5e5;
        }

        /* Table */
        .admin-table {
            width: 100%;
            border-collapse: collapse;
        }

        .admin-table thead {
            background: #1a1a1a;
        }

        .admin-table th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            border-bottom: 1px solid #2a2a2a;
        }

        .admin-table td {
            padding: 18px 15px;
            border-bottom: 1px solid #1a1a1a;
            color: #e5e5e5;
            font-size: 14px;
        }

        .admin-table tbody tr {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .admin-table tbody tr:hover {
            background: rgba(26, 26, 26, 0.5);
        }

        .admin-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn-action {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .btn-view {
            background: #1a1a1a;
            color: #e5e5e5;
            border: 1px solid #4a4a4a;
        }

        .btn-view:hover {
            background: #222222;
            border-color: #6a6a6a;
            transform: translateY(-2px);
            transform: translateY(-1px);
        }

        .btn-blacklist {
            background: #1a1a1a;
            color: #ef4444;
            border: 1px solid #4a4a4a;
        }

        .btn-blacklist:hover {
            background: #222222;
            border-color: #6a6a6a;
            transform: translateY(-2px);
        }

        .btn-unblacklist {
            background: #1a1a1a;
            color: #22c55e;
            border: 1px solid #4a4a4a;
        }

        .btn-unblacklist:hover {
            background: #222222;
            border-color: #6a6a6a;
            transform: translateY(-2px);
        }

        .btn-delete {
            background: #1a1a1a;
            color: #ef4444;
            border: 1px solid #4a4a4a;
        }

        .btn-delete:hover {
            background: #222222;
            border-color: #6a6a6a;
            transform: translateY(-2px);
        }

        /* Status Badge */
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-active {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .status-blacklisted {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(26, 26, 26, 0.98) 0%, rgba(37, 37, 37, 0.98) 100%);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.8);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            font-size: 22px;
            font-weight: 700;
            color: #e5e5e5;
        }

        .modal-close {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ef4444;
            font-size: 24px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(239, 68, 68, 0.2);
            transform: scale(1.05);
        }

        .modal-body {
            color: #e5e5e5;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(74, 74, 74, 0.3);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #888;
            font-weight: 600;
        }

        .info-value {
            color: #e5e5e5;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 16px;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e5e5e5;
            font-weight: 600;
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(74, 74, 74, 0.6);
            border-radius: 8px;
            color: #e5e5e5;
            font-size: 14px;
            transition: all 0.3s;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .form-input textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        /* Ticket Image Preview Styles */
        .ticket-image-preview {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .ticket-image-preview-item {
            position: relative;
            width: 80px;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(59, 130, 246, 0.4);
        }
        
        .ticket-image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .ticket-image-preview-item button {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(239, 68, 68, 0.9);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .ticket-image-preview-item button:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
        }
        
        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Ticket Modal Styles - Match User UI Exactly */
        .ticket-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }

        .ticket-modal.active {
            display: flex;
        }

        .ticket-modal-content {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            width: 100%;
            max-width: 700px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Ticket Message Styles - Match User UI */
        .ticket-messages {
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 16px;
            background: #000;
            border: 1px solid #1a1a1a;
            border-radius: 4px;
        }

        .ticket-message {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: 4px;
            max-width: 80%;
        }

        .ticket-message.user {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            margin-left: auto;
        }

        .ticket-message.admin {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .ticket-message-header {
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticket-message-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid rgba(74, 74, 74, 0.5);
        }

        .ticket-message-user-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticket-message-username {
            font-weight: 600;
            color: #e5e5e5;
        }

        .ticket-message-text {
            color: #e5e5e5;
            font-size: 14px;
            line-height: 1.5;
        }

        .ticket-message-image {
            margin-top: 12px;
            border-radius: 8px;
            overflow: hidden;
            max-width: 100%;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .ticket-message-image:hover {
            transform: scale(1.02);
        }

        .ticket-message-image img {
            width: 100%;
            height: auto;
            display: block;
            max-width: 400px;
        }

        .ticket-voice-message {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .ticket-voice-player {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ticket-voice-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            color: #3b82f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .ticket-voice-play-btn:hover {
            background: rgba(59, 130, 246, 0.3);
        }
        
        .ticket-voice-duration {
            font-size: 12px;
            color: #888;
            min-width: 50px;
        }
        
        .ticket-attach-btn, .ticket-voice-btn {
            padding: 12px 16px;
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            color: #e5e5e5;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .ticket-attach-btn:hover, .ticket-voice-btn:hover {
            background: #222222;
            border-color: #6a6a6a;
        }

        .ticket-voice-btn.recording {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #ef4444;
            animation: pulse 1.5s infinite;
        }

        .ticket-attach-btn svg, .ticket-voice-btn svg {
            width: 18px;
            height: 18px;
        }

        .ticket-send-btn {
            padding: 12px 24px;
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            color: #e5e5e5;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ticket-send-btn:hover:not(:disabled) {
            background: #222222;
            border-color: #6a6a6a;
        }

        .ticket-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ticket-input {
            flex: 1;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            color: #e5e5e5;
            font-size: 14px;
            font-family: inherit;
        }

        .ticket-input:focus {
            outline: none;
            border-color: #6a6a6a;
        }
        
        .ticket-modal-body {
            padding: 24px;
            flex: 1;
            overflow-y: auto;
        }
        
        .ticket-form-group {
            margin-bottom: 20px;
        }
        
        .ticket-form-group:last-child {
            margin-bottom: 0;
        }
        
        .ticket-modal-header {
            padding: 24px;
            border-bottom: 1px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ticket-modal-header button {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .ticket-modal-header button:hover {
            color: #ef4444;
            transform: rotate(90deg);
        }
        
        .ticket-input-area {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Changelog Changes List */
        .changelog-change-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(74, 74, 74, 0.5);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .changelog-change-item-text {
            flex: 1;
            color: #e5e5e5;
            font-size: 14px;
        }

        .changelog-change-item-remove {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            padding: 4px 8px;
            color: #ef4444;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .changelog-change-item-remove:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .admin-container {
                padding: 15px;
            }

            .admin-header {
                flex-direction: column;
                gap: 15px;
            }

            .admin-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .admin-tab {
                min-width: 120px;
                padding: 12px 16px;
                font-size: 13px;
            }

            .admin-table {
                font-size: 12px;
            }

            .admin-table th,
            .admin-table td {
                padding: 10px 8px;
            }

            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <div class="admin-header">
            <div class="admin-header-left">
                <div class="admin-logo">‚ö°</div>
                <div class="admin-header-title">Admin Control Panel</div>
            </div>
            <div class="admin-header-right">
                <button class="admin-btn admin-btn-primary" onclick="window.location.href='/'">
                    ‚Üê Back to Site
                </button>
                <button class="admin-btn admin-btn-danger" onclick="logout()">
                    Logout
                </button>
            </div>
        </div>

        <!-- Tabs -->
        <div class="admin-tabs">
            <button class="admin-tab active" data-tab="announcements">Announcements</button>
            <button class="admin-tab" data-tab="changelog">Changelog</button>
            <button class="admin-tab" data-tab="reviews">Reviews</button>
            <button class="admin-tab" data-tab="users">Users</button>
            <button class="admin-tab" data-tab="blacklisted">Blacklisted</button>
            <button class="admin-tab" data-tab="maintenance">Maintenance</button>
            <button class="admin-tab" data-tab="backup">Backup & Restore</button>
            <button class="admin-tab" data-tab="surveys">Surveys & Polls</button>
            <button class="admin-tab" data-tab="webhooks">Discord Webhooks</button>
            <button class="admin-tab" data-tab="tickets">Tickets</button>
            <button class="admin-tab" data-tab="profiles">User Profiles</button>
            <button class="admin-tab" data-tab="keys">License Keys</button>
            <button class="admin-tab" data-tab="finalReseller">Final Reseller</button>
            <button class="admin-tab" data-tab="grant">Grant</button>
            <button class="admin-tab" data-tab="ownerManagement">Owner Management</button>
        </div>

        <!-- Announcements Tab -->
        <div class="admin-content-card" id="tabAnnouncements">
            <h2>Announcements Management</h2>
            <button class="admin-btn admin-btn-primary" style="margin-bottom: 20px;" onclick="editAnnouncement(null)">+ Add Announcement</button>
            <div id="announcementsContent">
                <div class="loading">Loading announcements...</div>
            </div>
        </div>

        <!-- Changelog Tab -->
        <div class="admin-content-card" id="tabChangelog" style="display: none;">
            <h2>Changelog Management</h2>
            <button class="admin-btn admin-btn-primary" style="margin-bottom: 20px;" onclick="editChangelog(null)">+ Add Changelog Entry</button>
            <div id="changelogContent">
                <div class="loading">Loading changelog...</div>
            </div>
        </div>

        <!-- Reviews Tab -->
        <div class="admin-content-card" id="tabReviews" style="display: none;">
            <h2>Reviews Management</h2>
            <div id="reviewsContent">
                <div class="loading">Loading reviews...</div>
            </div>
        </div>

        <!-- Users Tab -->
        <div class="admin-content-card" id="tabUsers" style="display: none;">
            <h2>User Management</h2>
            <div id="usersContent">
                <div class="loading">Loading users...</div>
            </div>
        </div>

        <!-- Blacklisted Users Tab -->
        <div class="admin-content-card" id="tabBlacklisted" style="display: none;">
            <h2>Blacklisted Users</h2>
            <div id="blacklistedContent">
                <div class="loading">Loading blacklisted users...</div>
            </div>
        </div>

        <!-- Maintenance Tab -->
        <div class="admin-content-card" id="tabMaintenance" style="display: none;">
            <h2>Maintenance Mode</h2>
            <div id="maintenanceContent">
                <div class="loading">Loading maintenance settings...</div>
            </div>
        </div>

        <!-- Backup & Restore Tab -->
        <div class="admin-content-card" id="tabBackup" style="display: none;">
            <h2>Backup & Restore</h2>
            <div id="backupContent">
                <div class="loading">Loading backup tools...</div>
            </div>
        </div>

        <!-- Surveys & Polls Tab -->
        <div class="admin-content-card" id="tabSurveys" style="display: none;">
            <h2>Surveys & Polls Management</h2>
            <button class="admin-btn admin-btn-primary" style="margin-bottom: 20px;" onclick="editSurvey(null)">+ Create Survey/Poll</button>
            <div id="surveysContent">
                <div class="loading">Loading surveys...</div>
            </div>
        </div>

        <!-- Discord Webhooks Tab -->
        <div class="admin-content-card" id="tabWebhooks" style="display: none;">
            <h2>Discord Webhook Integration</h2>
            <button class="admin-btn admin-btn-primary" style="margin-bottom: 20px;" onclick="createWebhook()">+ Create Webhook</button>
            <div id="webhooksContent">
                <div class="loading">Loading webhooks...</div>
            </div>
        </div>

        <!-- Tickets Tab -->
        <div class="admin-content-card" id="tabTickets" style="display: none;">
            <h2>Support Tickets</h2>
            <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                <select id="ticketFilterStatus" class="form-input" style="flex: 1; min-width: 150px;" onchange="loadTickets()">
                    <option value="all">All Status</option>
                    <option value="open">Open</option>
                    <option value="closed">Closed</option>
                </select>
                <input type="text" id="ticketSearchInput" class="form-input" placeholder="Search tickets..." style="flex: 2; min-width: 200px;" oninput="loadTickets()">
            </div>
            <div id="ticketsContent">
                <div class="loading">Loading tickets...</div>
            </div>
        </div>

        <!-- License Keys Tab -->
        <div class="admin-content-card" id="tabKeys" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">License Key Management</h2>
                <button class="admin-btn" onclick="syncKeyStatus()" title="Refresh key status">üîÑ Sync Status</button>
            </div>
            <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 4px; padding: 12px; margin-bottom: 20px; font-size: 13px; color: #93c5fd;">
                <strong>‚ÑπÔ∏è Note:</strong> KeyAuth API may require server-side authentication or may not support browser-based requests. If you encounter errors, you may need to use KeyAuth's owner API or set up a server-side proxy.
            </div>
            <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;">
                <button class="admin-btn admin-btn-primary" onclick="showGenerateKeyModal()">+ Generate Key</button>
                <input type="text" id="keySearchInput" class="form-input" placeholder="Search keys..." style="flex: 1; min-width: 200px;" oninput="loadKeys()">
                <select id="keyFilterStatus" class="form-input" style="min-width: 150px;" onchange="loadKeys()">
                    <option value="all">All Keys</option>
                    <option value="used">Used</option>
                    <option value="unused">Unused</option>
                    <option value="expired">Expired</option>
                </select>
                <button class="admin-btn" onclick="exportKeys()" title="Export all keys to CSV">üì• Export</button>
            </div>
            <div id="keysContent">
                <div class="loading">Loading keys...</div>
            </div>
        </div>

        <!-- User Profiles Tab -->
        <div class="admin-content-card" id="tabProfiles" style="display: none;">
            <h2>User Profiles Management</h2>
            <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                <input type="text" id="profileSearchInput" class="form-input" placeholder="Search profiles by username..." style="flex: 2; min-width: 200px;" oninput="loadUserProfiles()">
            </div>
            <div id="profilesContent">
                <div class="loading">Loading profiles...</div>
            </div>
        </div>

        <!-- Final Reseller Tab -->
        <div class="admin-content-card" id="tabFinalReseller" style="display: none;">
            <h2>Final Reseller</h2>
            <p style="color: #888; margin-bottom: 20px;">Final Reseller management interface</p>
            <div id="finalResellerContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <!-- Grant Tab -->
        <div class="admin-content-card" id="tabGrant" style="display: none;">
            <h2>Grant Admin Access</h2>
            <p style="color: #888; margin-bottom: 20px;">Select a user to grant restricted admin access (License Keys tab only)</p>
            
            <div class="form-group" style="margin-bottom: 20px;">
                <label>Search Users</label>
                <input type="text" id="grantUserSearch" class="form-input" placeholder="Search by username..." style="margin-bottom: 10px;" oninput="loadUsersForGrant()">
                <div id="grantUserList" style="max-height: 400px; overflow-y: auto; background: rgba(26, 26, 26, 0.5); border-radius: 4px; padding: 10px;"></div>
            </div>

            <div id="grantSelectedUser" style="display: none; margin-bottom: 20px; padding: 15px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 4px;">
                <h3 style="color: #e5e5e5; margin-bottom: 10px; font-size: 16px;">Selected User</h3>
                <div id="grantSelectedUserInfo" style="color: #888; margin-bottom: 15px;"></div>
                <div style="margin-top: 15px;">
                    <label style="display: flex; align-items: center; color: #e5e5e5; margin-bottom: 10px; cursor: pointer;">
                        <input type="checkbox" id="grantAccessToGrantTab" style="margin-right: 8px; cursor: pointer;">
                        Grant access to Grant tab (can grant access to others)
                    </label>
                    <div style="display: flex; gap: 10px;">
                        <button class="admin-btn admin-btn-primary" id="grantAccessBtn" onclick="grantUserAccess()">Grant Access</button>
                        <button class="admin-btn" id="revokeAccessBtn" onclick="revokeUserAccess()" style="background: #ef4444;">Revoke Access</button>
                    </div>
                </div>
            </div>

            <div style="margin-top: 30px;">
                <h3 style="color: #e5e5e5; margin-bottom: 15px; font-size: 18px;">Granted Users</h3>
                <div id="grantedUsersList"></div>
            </div>
        </div>

        <!-- Owner Management Tab -->
        <div class="admin-content-card" id="tabOwnerManagement" style="display: none;">
            <h2>Owner Management</h2>
            <p style="color: #888; margin-bottom: 20px;">Remove admin panel access for Aiden and Yyy</p>
            
            <div id="ownerManagementList" style="margin-top: 20px;"></div>
        </div>
    </div>

    <!-- User Info Modal -->
    <div class="modal" id="userInfoModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>User Information</h3>
                <button class="modal-close" onclick="closeModal('userInfoModal')">√ó</button>
            </div>
            <div class="modal-body" id="userInfoContent">
                <!-- User info will be populated here -->
            </div>
        </div>
    </div>

    <!-- Announcement Editor Modal -->
    <div class="modal" id="announcementEditorModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3 id="announcementEditorTitle">Add Announcement</h3>
                <button class="modal-close" onclick="hideAnnouncementEditor()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Title *</label>
                    <input type="text" id="announcementTitleInput" class="form-input" placeholder="New Update Available!" maxlength="100">
                </div>
                <div class="form-group">
                    <label>Message *</label>
                    <textarea id="announcementMessageInput" class="form-input" rows="4" placeholder="Version 1.2.0 is now live with exciting new features." maxlength="500"></textarea>
                </div>
                <div class="form-group">
                    <label>Type *</label>
                    <select id="announcementTypeInput" class="form-input">
                        <option value="info">Info (Blue)</option>
                        <option value="success">Success (Green)</option>
                        <option value="warning">Warning (Orange)</option>
                        <option value="error">Error (Red)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Priority *</label>
                    <select id="announcementPriorityInput" class="form-input">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>End Date (Optional)</label>
                    <input type="datetime-local" id="announcementEndDateInput" class="form-input">
                    <div style="font-size: 12px; color: #888; margin-top: 4px;">Leave empty to show indefinitely</div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="announcementDismissibleInput" checked> Dismissible (users can close)
                    </label>
                </div>
                <div class="form-group">
                    <label>Link URL (Optional)</label>
                    <input type="url" id="announcementLinkInput" class="form-input" placeholder="https://...">
                </div>
                <div class="form-group">
                    <label>Link Text (Optional)</label>
                    <input type="text" id="announcementLinkTextInput" class="form-input" placeholder="Learn More">
                </div>
                <div id="announcementEditorError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-primary" onclick="saveAnnouncement()" style="flex: 1;">Save Announcement</button>
                    <button class="admin-btn" onclick="hideAnnouncementEditor()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Changelog Editor Modal -->
    <div class="modal" id="changelogEditorModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3 id="changelogEditorTitle">Add Changelog Entry</h3>
                <button class="modal-close" onclick="hideChangelogEditor()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Version *</label>
                    <input type="text" id="changelogVersionInput" class="form-input" placeholder="1.2.0" maxlength="20">
                </div>
                <div class="form-group">
                    <label>Release Date *</label>
                    <input type="date" id="changelogDateInput" class="form-input">
                </div>
                <div class="form-group">
                    <label>Type (Optional)</label>
                    <select id="changelogTypeInput" class="form-input">
                        <option value="">None</option>
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="patch">Patch</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Download URL (Optional)</label>
                    <input type="url" id="changelogDownloadUrlInput" class="form-input" placeholder="https://github.com/.../releases/tag/v1.2.0">
                </div>
                <div class="form-group">
                    <label>Changes *</label>
                    <div id="changelogChangesList" style="margin-bottom: 12px;"></div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <input type="text" id="changelogChangeInput" class="form-input" placeholder="Added new feature..." style="flex: 1;" maxlength="200">
                        <button type="button" class="btn-action btn-view" onclick="addChangelogChange()" style="white-space: nowrap;">+ Add</button>
                    </div>
                    <div style="font-size: 12px; color: #888; margin-top: 4px;">Add each change as a separate item</div>
                </div>
                <div id="changelogEditorError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-primary" onclick="saveChangelog()" style="flex: 1;">Save Changelog</button>
                    <button class="admin-btn" onclick="hideChangelogEditor()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Blacklist Editor Modal -->
    <div class="modal" id="blacklistEditorModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 id="blacklistEditorTitle">Blacklist User</h3>
                <button class="modal-close" onclick="closeBlacklistModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>IP Address *</label>
                    <input type="text" id="blacklistIpInput" class="form-input" placeholder="192.168.1.1" readonly>
                </div>
                <div class="form-group">
                    <label>Reason *</label>
                    <select id="blacklistReasonInput" class="form-input">
                        <option value="Spam">Spam</option>
                        <option value="Abuse">Abuse</option>
                        <option value="Suspicious Activity">Suspicious Activity</option>
                        <option value="Terms Violation">Terms Violation</option>
                        <option value="Other" selected>Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Notes (Optional)</label>
                    <textarea id="blacklistNotesInput" class="form-input" rows="4" placeholder="Additional details about why this user was blacklisted..."></textarea>
                </div>
                <div id="blacklistError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-danger" onclick="saveBlacklist()" style="flex: 1;">Blacklist User</button>
                    <button class="admin-btn" onclick="closeBlacklistModal()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Survey Editor Modal -->
    <div class="modal" id="surveyEditorModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3 id="surveyEditorTitle">Create Survey/Poll</h3>
                <button class="modal-close" onclick="hideSurveyEditor()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Title *</label>
                    <input type="text" id="surveyTitleInput" class="form-input" placeholder="What do you think about our new feature?" maxlength="200">
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="surveyDescriptionInput" class="form-input" rows="3" placeholder="Share your thoughts..." maxlength="500"></textarea>
                </div>
                <div class="form-group">
                    <label>Type *</label>
                    <select id="surveyTypeInput" class="form-input">
                        <option value="poll">Poll (Single Choice)</option>
                        <option value="survey">Survey (Multiple Choice)</option>
                        <option value="rating">Rating (1-5 Stars)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Options *</label>
                    <div id="surveyOptionsList" style="margin-bottom: 12px;"></div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <input type="text" id="surveyOptionInput" class="form-input" placeholder="Enter option..." style="flex: 1;" maxlength="100">
                        <button type="button" class="btn-action btn-view" onclick="addSurveyOption()" style="white-space: nowrap;">+ Add</button>
                    </div>
                    <div style="font-size: 12px; color: #888; margin-top: 4px;">Add at least 2 options</div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="surveyActiveInput" checked> Active (visible on site)
                    </label>
                </div>
                <div id="surveyEditorError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-primary" onclick="saveSurvey()" style="flex: 1;">Save Survey</button>
                    <button class="admin-btn" onclick="hideSurveyEditor()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Discord Webhook Editor Modal -->
    <div class="modal" id="webhookEditorModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 id="webhookEditorTitle">Create Discord Webhook</h3>
                <button class="modal-close" onclick="hideWebhookEditor()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Webhook Name *</label>
                    <input type="text" id="webhookNameInput" class="form-input" placeholder="My Webhook" maxlength="100">
                </div>
                <div class="form-group">
                    <label>Webhook URL *</label>
                    <input type="url" id="webhookUrlInput" class="form-input" placeholder="https://discord.com/api/webhooks/..." maxlength="500">
                    <div style="font-size: 12px; color: #888; margin-top: 4px;">Get your webhook URL from Discord channel settings</div>
                </div>
                
                <div style="border-top: 1px solid #2a2a2a; margin: 20px 0; padding-top: 20px;">
                    <h4 style="color: #e5e5e5; margin-bottom: 16px;">Embed Builder</h4>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <div class="form-group">
                                <label>Title</label>
                                <input type="text" id="embedTitleInput" class="form-input" placeholder="Embed Title" maxlength="256">
                            </div>
                            <div class="form-group">
                                <label>Description</label>
                                <textarea id="embedDescriptionInput" class="form-input" rows="4" placeholder="Embed description..." maxlength="4096"></textarea>
                            </div>
                            <div class="form-group">
                                <label>URL (makes title clickable)</label>
                                <input type="url" id="embedUrlInput" class="form-input" placeholder="https://..." maxlength="500">
                            </div>
                            <div class="form-group">
                                <label>Color</label>
                                <input type="color" id="embedColorInput" class="form-input" value="#5865F2" style="height: 40px;">
                            </div>
                        </div>
                        <div>
                            <div class="form-group">
                                <label>Author Name</label>
                                <input type="text" id="embedAuthorNameInput" class="form-input" placeholder="Author" maxlength="256">
                            </div>
                            <div class="form-group">
                                <label>Author Icon URL</label>
                                <input type="url" id="embedAuthorIconInput" class="form-input" placeholder="https://..." maxlength="500">
                            </div>
                            <div class="form-group">
                                <label>Footer Text</label>
                                <input type="text" id="embedFooterInput" class="form-input" placeholder="Footer" maxlength="2048">
                            </div>
                            <div class="form-group">
                                <label>Footer Icon URL</label>
                                <input type="url" id="embedFooterIconInput" class="form-input" placeholder="https://..." maxlength="500">
                            </div>
                            <div class="form-group">
                                <label>Thumbnail URL</label>
                                <input type="url" id="embedThumbnailInput" class="form-input" placeholder="https://..." maxlength="500">
                            </div>
                            <div class="form-group">
                                <label>Image URL</label>
                                <input type="url" id="embedImageInput" class="form-input" placeholder="https://..." maxlength="500">
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Fields</label>
                        <div id="embedFieldsList" style="margin-bottom: 12px;"></div>
                        <button type="button" class="btn-action btn-view" onclick="addEmbedField()" style="margin-bottom: 12px;">+ Add Field</button>
                    </div>
                    
                    <div class="form-group">
                        <label>Timestamp</label>
                        <select id="embedTimestampInput" class="form-input">
                            <option value="none">None</option>
                            <option value="now" selected>Current Time</option>
                            <option value="custom">Custom</option>
                        </select>
                        <input type="datetime-local" id="embedTimestampCustomInput" class="form-input" style="margin-top: 8px; display: none;">
                    </div>
                </div>
                
                <div style="border-top: 1px solid #2a2a2a; margin: 20px 0; padding-top: 20px;">
                    <h4 style="color: #e5e5e5; margin-bottom: 16px;">Preview</h4>
                    <div id="embedPreview" style="background: #2f3136; border-left: 4px solid #5865F2; padding: 16px; border-radius: 4px; margin-bottom: 20px; min-height: 100px;">
                        <div style="color: #dcddde; font-size: 14px;">Preview will appear here...</div>
                    </div>
                    <button type="button" class="admin-btn" onclick="updateEmbedPreview()" style="margin-bottom: 12px;">üîÑ Update Preview</button>
                    <button type="button" class="admin-btn admin-btn-primary" onclick="testWebhook()" style="margin-bottom: 12px;">üì§ Send Test Message</button>
                </div>
                
                <div id="webhookEditorError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-primary" onclick="saveWebhook()" style="flex: 1;">Save Webhook</button>
                    <button class="admin-btn" onclick="hideWebhookEditor()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Key Generation Modal -->
    <div class="ticket-modal" id="generateKeyModal">
        <div class="ticket-modal-content" style="max-width: 600px;">
            <div class="ticket-modal-header">
                <h3 style="margin: 0;">Generate License Key</h3>
                <button onclick="closeGenerateKeyModal()">√ó</button>
            </div>
            <div class="ticket-modal-body">
                <div class="form-group">
                    <label class="ticket-form-label">Key Level/Subscription *</label>
                    <input type="text" id="keyLevelInput" class="ticket-input" placeholder="e.g., Premium, Pro, Lifetime" value="Premium" maxlength="50">
                    <small style="color: #888; font-size: 12px; margin-top: 4px; display: block;">Subscription name for this key</small>
                </div>
                
                <div class="form-group">
                    <label class="ticket-form-label">Expiration (Days)</label>
                    <input type="number" id="keyExpiryInput" class="ticket-input" placeholder="Leave empty for lifetime" min="1" max="36500">
                    <small style="color: #888; font-size: 12px; margin-top: 4px; display: block;">Number of days until expiration (empty = lifetime)</small>
                </div>
                
                <div class="form-group">
                    <label class="ticket-form-label">Number of Keys</label>
                    <input type="number" id="keyCountInput" class="ticket-input" value="1" min="1" max="100">
                    <small style="color: #888; font-size: 12px; margin-top: 4px; display: block;">Generate multiple keys at once (1-100)</small>
                </div>
                
                <div class="form-group">
                    <label class="ticket-form-label">Notes (Optional)</label>
                    <textarea id="keyNotesInput" class="ticket-textarea" rows="3" placeholder="Internal notes about this key..." maxlength="500"></textarea>
                </div>
                
                <div id="keyGenerationError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="ticket-send-btn" onclick="generateKey()" style="flex: 1;">Generate Key(s)</button>
                    <button class="ticket-send-btn ticket-btn-secondary" onclick="closeGenerateKeyModal()" style="flex: 1;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Admin Ticket View Modal -->
    <div class="ticket-modal" id="adminTicketModal">
        <div class="ticket-modal-content" style="max-width: 800px;">
            <div class="ticket-modal-header">
                <div>
                    <h3 id="adminTicketTitle" style="margin: 0 0 4px 0;">Ticket</h3>
                    <div style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-top: 4px;" id="adminTicketId"></div>
                </div>
                <button onclick="closeAdminTicketModal()">√ó</button>
            </div>
            <div class="ticket-modal-body">
                <div class="ticket-messages" id="adminTicketMessages">
                    <div style="color: #888; text-align: center; padding: 40px;">Loading messages...</div>
                </div>
                <div class="ticket-form-group" style="margin-bottom: 0;">
                    <div class="ticket-image-preview" id="adminTicketImagePreview"></div>
                    <div class="ticket-input-area">
                        <input type="text" id="adminTicketReplyInput" class="ticket-input" placeholder="Type your message..." maxlength="1000" style="flex: 1;" onkeypress="if(event.key === 'Enter') sendAdminTicketMessage()">
                        <input type="file" id="adminTicketImageInput" accept="image/*" multiple style="display: none;">
                        <button class="ticket-attach-btn" onclick="document.getElementById('adminTicketImageInput').click()" title="Attach Images">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                        </button>
                        <button class="ticket-voice-btn" id="adminTicketVoiceBtn" onmousedown="TicketSystemAdmin.startRecording()" onmouseup="TicketSystemAdmin.stopRecording()" ontouchstart="event.preventDefault(); TicketSystemAdmin.startRecording()" ontouchend="event.preventDefault(); TicketSystemAdmin.stopRecording()" title="Hold to Record">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                            </svg>
                        </button>
                        <button class="ticket-send-btn" onclick="sendAdminTicketMessage()" id="adminTicketSendBtn">Send</button>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; margin-top: 16px;">
                    <button class="admin-btn" onclick="closeAdminTicket()" id="closeTicketBtn" style="flex: 1;">Close Ticket</button>
                    <button class="admin-btn" onclick="saveTicketTranscript()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Save Transcript</button>
                    <button class="admin-btn admin-btn-danger" onclick="deleteAdminTicketFromModal()" style="flex: 1;">Delete Ticket</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Maintenance Mode Modal -->
    <div class="modal" id="maintenanceModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>Configure Maintenance Mode</h3>
                <button class="modal-close" onclick="closeMaintenanceModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="maintenanceEnabled" style="width: 20px; height: 20px; cursor: pointer;"> 
                        <span>Enable Maintenance Mode</span>
                    </label>
                </div>
                <div class="form-group">
                    <label>Maintenance Message *</label>
                    <textarea id="maintenanceMessage" class="form-input" rows="4" placeholder="We're currently performing scheduled maintenance. We'll be back shortly!">We're currently performing scheduled maintenance. We'll be back shortly!</textarea>
                </div>
                <div class="form-group">
                    <label>Estimated Return Time (Optional)</label>
                    <input type="datetime-local" id="maintenanceReturnTime" class="form-input">
                </div>
                <div id="maintenanceError" style="color: #ef4444; font-size: 13px; margin-bottom: 16px; display: none;"></div>
                <div style="display: flex; gap: 12px; margin-top: 20px;">
                    <button class="admin-btn admin-btn-primary" onclick="saveMaintenanceSettings()" style="flex: 1;">Save Settings</button>
                    <button class="admin-btn" onclick="closeMaintenanceModal()" style="flex: 1; background: rgba(74, 74, 74, 0.3);">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration (same as index.html)
        const firebaseConfig = {
            apiKey: "AIzaSyC6CrMVEbsr-AADq-w-TOkzO0AAOZtUqmU",
            authDomain: "recon-265bc.firebaseapp.com",
            databaseURL: "https://recon-265bc-default-rtdb.firebaseio.com",
            projectId: "recon-265bc",
            storageBucket: "recon-265bc.firebasestorage.app",
            messagingSenderId: "99005456592",
            appId: "1:99005456592:web:9ca83e210d9e85ca8a3ed5"
        };

        // ============================================
        // DEVELOPER TOOLS PROTECTION (Non-Blocking)
        // ============================================
        // This prevents DevTools access but does NOT block users from the page
        
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        }, false);
        
        // Disable common keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Disable F12 (DevTools)
            if (e.key === 'F12' || e.keyCode === 123) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+Shift+I (DevTools)
            if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.keyCode === 73)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+Shift+J (Console)
            if (e.ctrlKey && e.shiftKey && (e.key === 'J' || e.keyCode === 74)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+Shift+C (Inspect Element)
            if (e.ctrlKey && e.shiftKey && (e.key === 'C' || e.keyCode === 67)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+U (View Source)
            if (e.ctrlKey && (e.key === 'u' || e.key === 'U' || e.keyCode === 85)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+S (Save Page)
            if (e.ctrlKey && (e.key === 's' || e.key === 'S' || e.keyCode === 83)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // Disable Ctrl+P (Print)
            if (e.ctrlKey && (e.key === 'p' || e.key === 'P' || e.keyCode === 80)) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);
        
        // Disable text selection
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
            return false;
        }, false);
        
        // Disable drag
        document.addEventListener('dragstart', function(e) {
            e.preventDefault();
            return false;
        }, false);
        
        // Console Protection (disable console methods)
        (function() {
            const noop = function() {};
            const methods = ['log', 'debug', 'info', 'warn', 'error', 'assert', 'clear', 'count', 'dir', 'dirxml', 'group', 'groupCollapsed', 'groupEnd', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'memory'];
            
            // Override console methods to prevent logging
            methods.forEach(function(method) {
                try {
                    window.console[method] = noop;
                } catch(e) {
                    try {
                        Object.defineProperty(window.console, method, {
                            get: function() { return noop; },
                            set: function() {}
                        });
                    } catch(e2) {}
                }
            });
        })();
        
        // Clear console periodically
        setTimeout(function() {
            setInterval(function() {
                try {
                    console.clear();
                } catch(e) {}
            }, 1000);
        }, 3000);
        
        // Protect source code access (return empty instead of blocking)
        Object.defineProperty(window, 'devtools', {
            get: function() {
                return { open: false, orientation: null };
            },
            configurable: false
        });
        
        // Protect source code access
        Object.defineProperty(document, 'scripts', {
            get: function() {
                return [];
            },
            configurable: false
        });
        
        // Obfuscate source code access
        (function() {
            const scripts = document.getElementsByTagName('script');
            for (let i = 0; i < scripts.length; i++) {
                try {
                    Object.defineProperty(scripts[i], 'innerHTML', {
                        get: function() {
                            return '';
                        },
                        set: function() {}
                    });
                    Object.defineProperty(scripts[i], 'text', {
                        get: function() {
                            return '';
                        },
                        set: function() {}
                    });
                } catch(e) {}
            }
        })();
        
        // ============================================
        // FIREBASE INITIALIZATION
        // ============================================
        
        // Initialize Firebase
        window.firebaseInitialized = false;
        window.database = null;
        
        try {
            firebase.initializeApp(firebaseConfig);
            window.database = firebase.database();
            window.firebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
            window.firebaseInitialized = false;
        }

        // Check admin access (User ID-based)
        const USER_PROFILE_ID_KEY = 'recon_user_profile_id';
        const ALLOWED_ADMIN_USER_IDS = [
            'user_1764492219870_1nmahxwjb',
            'user_1764533348919_8pq7xrq95'
        ];
        
        async function verifyAdminAccess() {
            try {
                // Wait for Firebase to initialize if not ready (increased retries and wait time)
                let retries = 0;
                while (!window.firebaseInitialized && retries < 20) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    retries++;
                }
                
                // Check if user is logged in
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                
                if (!userProfileId) {
                    alert('Access denied. Please log in to access the admin panel.');
                    window.location.href = '/';
                    return false;
                }
                
                // Check if user is in allowed admin list
                const isAllowedAdmin = ALLOWED_ADMIN_USER_IDS.includes(userProfileId);
                
                if (isAllowedAdmin) {
                    console.log('‚úÖ Admin access verified - User ID:', userProfileId, '(Full Admin)');
                    return true;
                }
                
                // Check for granted access if not a full admin
                let hasGrantedAccess = false;
                if (window.firebaseInitialized && window.database) {
                    try {
                        console.log('Checking granted access for user:', userProfileId);
                        const grantedSnapshot = await window.database.ref(`admin/grantedAccess/${userProfileId}`).once('value');
                        hasGrantedAccess = grantedSnapshot.exists();
                        console.log('Granted access check result:', hasGrantedAccess);
                        if (hasGrantedAccess) {
                            const accessData = grantedSnapshot.val();
                            console.log('Granted access data:', accessData);
                        }
                    } catch (error) {
                        console.error('Error checking granted access:', error);
                        console.error('Error details:', error.message, error.stack);
                        // Don't fail immediately, try to continue
                    }
                } else {
                    console.warn('Firebase not initialized or database not available. firebaseInitialized:', window.firebaseInitialized, 'database:', !!window.database);
                    // Wait a bit more and try again
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (window.firebaseInitialized && window.database) {
                        try {
                            const grantedSnapshot = await window.database.ref(`admin/grantedAccess/${userProfileId}`).once('value');
                            hasGrantedAccess = grantedSnapshot.exists();
                            console.log('Granted access check result (retry):', hasGrantedAccess);
                        } catch (error) {
                            console.error('Error checking granted access (retry):', error);
                        }
                    }
                }
                
                if (!hasGrantedAccess) {
                    console.log('‚ùå Access denied - User ID:', userProfileId, 'isAllowedAdmin:', isAllowedAdmin, 'hasGrantedAccess:', hasGrantedAccess);
                    alert('Access denied. Your account is not authorized for admin access.');
                    window.location.href = '/';
                    return false;
                }
                
                // Verify user profile still exists in Firebase
                if (window.firebaseInitialized && window.database) {
                    try {
                        const profileSnapshot = await window.database.ref(`userProfiles/${userProfileId}`).once('value');
                        if (!profileSnapshot.exists()) {
                            alert('Access denied. Your account no longer exists.');
                            localStorage.removeItem(USER_PROFILE_ID_KEY);
                            localStorage.removeItem('recon_auth_token');
                            window.location.href = '/';
                            return false;
                        }
                    } catch (error) {
                        console.error('Error verifying user profile:', error);
                        // Continue anyway if Firebase check fails
                    }
                }
                
                console.log('‚úÖ Admin access verified - User ID:', userProfileId, '(Granted Access)');
                return true;
            } catch (error) {
                console.error('Error verifying admin access:', error);
                console.error('Error details:', error.message, error.stack);
                alert('Error verifying admin access. Please try again.');
                window.location.href = '/';
                return false;
            }
        }
        
        // Update admin tabs visibility based on access level
        async function updateAdminTabsVisibility() {
            const access = await getUserAccessLevel();
            if (!access) return;

            console.log('Updating admin tabs visibility. Access level:', access);

            // Get all tabs
            const allTabs = document.querySelectorAll('.admin-tab');
            const allTabContents = document.querySelectorAll('.admin-content-card');

            if (access.level === 'granted') {
                // Granted user - show License Keys tab, and Grant tab if canGrant is true
                const allowedTabs = ['keys'];
                if (access.canGrant) {
                    allowedTabs.push('grant');
                    console.log('User has canGrant permission - showing Grant tab');
                } else {
                    console.log('User does not have canGrant permission - only showing License Keys tab');
                }
                
                // Show/hide tabs
                allTabs.forEach(tab => {
                    const tabName = tab.getAttribute('data-tab');
                    if (allowedTabs.includes(tabName)) {
                        tab.style.display = 'block';
                        console.log(`Showing tab: ${tabName}`);
                    } else {
                        tab.style.display = 'none';
                        tab.classList.remove('active');
                    }
                });
                
                // Set first allowed tab as active if no tab is currently active
                const activeTab = document.querySelector('.admin-tab.active');
                if (!activeTab || !allowedTabs.includes(activeTab.getAttribute('data-tab'))) {
                    const firstAllowedTab = document.querySelector(`.admin-tab[data-tab="${allowedTabs[0]}"]`);
                    if (firstAllowedTab) {
                        document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
                        firstAllowedTab.classList.add('active');
                        console.log(`Set active tab: ${allowedTabs[0]}`);
                    }
                }
                
                // Show/hide tab contents based on active tab
                allTabContents.forEach(content => {
                    content.style.display = 'none';
                });
                
                const activeTabName = document.querySelector('.admin-tab.active')?.getAttribute('data-tab');
                console.log('Active tab:', activeTabName);
                
                if (activeTabName === 'keys') {
                    const keysContent = document.getElementById('tabKeys');
                    if (keysContent) {
                        keysContent.style.display = 'block';
                        updateLicenseKeysUIForGrantedUser();
                    }
                    // Load license keys
                    if (typeof loadKeys === 'function') {
                        loadKeys();
                    }
                } else if (activeTabName === 'grant' && access.canGrant) {
                    const grantContent = document.getElementById('tabGrant');
                    if (grantContent) {
                        grantContent.style.display = 'block';
                        console.log('Showing Grant tab content');
                    }
                    // Load grant data
                    if (typeof loadUsersForGrant === 'function') {
                        loadUsersForGrant();
                    }
                    if (typeof loadGrantedUsers === 'function') {
                        loadGrantedUsers();
                    }
                }
            } else if (access.level === 'full') {
                // Full admin - show all tabs
                allTabs.forEach(tab => {
                    tab.style.display = 'block';
                });
                // Restore full admin UI
                restoreLicenseKeysUIForAdmin();
            }
        }

        // Update License Keys UI for granted users (keep full functionality)
        function updateLicenseKeysUIForGrantedUser() {
            const tabKeys = document.getElementById('tabKeys');
            if (!tabKeys) return;

            // Update header to show it's their personal keys
            const header = tabKeys.querySelector('h2');
            if (header) {
                header.textContent = 'My License Keys';
            }

            // Keep all functionality - just update search to use loadKeys
            const searchInput = document.getElementById('keySearchInput');
            if (searchInput) {
                searchInput.setAttribute('oninput', 'loadKeys()');
            }
        }

        // Restore License Keys UI for full admin
        function restoreLicenseKeysUIForAdmin() {
            const tabKeys = document.getElementById('tabKeys');
            if (!tabKeys) return;

            // Restore header
            const header = tabKeys.querySelector('h2');
            if (header) {
                header.textContent = 'License Key Management';
            }
        }

        // Helper function to wait for database to be ready
        async function waitForDatabase(maxWait = 10000) {
            const startTime = Date.now();
            while (!window.database && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return !!window.database;
        }

        // Verify admin access immediately on page load
        // Run immediately and also after a short delay to ensure Firebase is ready
        (async function() {
            // Wait a bit for Firebase to initialize
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Wait for database to be ready
            const dbReady = await waitForDatabase(10000);
            if (!dbReady) {
                console.warn('Database not ready after 10 seconds, proceeding anyway...');
            }
            
            // First check
            const hasAccess = await verifyAdminAccess();
            if (hasAccess) {
                await updateAdminTabsVisibility();
            } else {
                // If access denied, wait a bit more and try once more (in case Firebase was slow)
                await new Promise(resolve => setTimeout(resolve, 2000));
                const hasAccessRetry = await verifyAdminAccess();
                if (hasAccessRetry) {
                    await updateAdminTabsVisibility();
                }
            }
        })();

        // Track admin panel visit (optional)
        async function trackUserVisit() {
            // Admin panel visits are tracked but not blocked by blacklist
            try {
                const ip = await getClientIP();
                const userAgent = navigator.userAgent;
                const timestamp = Date.now();
                const visitId = `visit_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;

                const visitData = {
                    ip: ip,
                    userAgent: userAgent,
                    timestamp: timestamp,
                    date: new Date().toISOString(),
                    url: window.location.href,
                    isAdmin: true
                };

                await database.ref(`visits/${visitId}`).set(visitData);
            } catch (error) {
                console.error('Error tracking visit:', error);
            }
        }

        // Get client IP (using a free service)
        async function getClientIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                // Fallback to a generated ID
                return 'unknown_' + Math.random().toString(36).substr(2, 9);
            }
        }

        // Load reviews
        async function loadReviews() {
            const content = document.getElementById('reviewsContent');
            try {
                const snapshot = await database.ref('ratings').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">‚≠ê</div><div class="empty-state-text">No reviews yet</div></div>';
                    return;
                }

                const ratings = snapshot.val();
                const reviews = Object.entries(ratings);

                if (reviews.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">‚≠ê</div><div class="empty-state-text">No reviews yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>User</th>
                                <th>Rating</th>
                                <th>Review</th>
                                <th>Timestamp</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // Load all profiles for reviews
                const profilesSnapshot = await database.ref('userProfiles').once('value');
                const profiles = profilesSnapshot.exists() ? profilesSnapshot.val() : {};

                for (const [id, review] of reviews) {
                    const date = new Date(review.timestamp || 0);
                    const stars = '‚≠ê'.repeat(review.rating || 0);
                    
                    // Get user profile if userId exists
                    let userHtml = '<span style="color: #888;">Anonymous</span>';
                    if (review.userId && profiles[review.userId]) {
                        const profile = profiles[review.userId];
                        const avatarSrc = profile.avatar || `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2232%22 height=%2232%22%3E%3Ccircle cx=%2216%22 cy=%2216%22 r=%2216%22 fill=%22%233a3a3a%22/%3E%3Ctext x=%2216%22 y=%2220%22 font-size=%2212%22 fill=%22%23fff%22 text-anchor=%22middle%22%3E${encodeURIComponent((profile.username || '?').charAt(0).toUpperCase())}%3C/text%3E%3C/svg%3E`;
                        userHtml = `
                            <div style="display: flex; align-items: center; gap: 8px; cursor: pointer;" onclick="viewUserProfile('${escapeHtml(review.userId)}')">
                                <img src="${escapeHtml(avatarSrc)}" alt="${escapeHtml(profile.username || 'User')}" 
                                     style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; border: 1px solid rgba(74, 74, 74, 0.5);"
                                     onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2232%22 height=%2232%22%3E%3Ccircle cx=%2216%22 cy=%2216%22 r=%2216%22 fill=%22%233a3a3a%22/%3E%3C/svg%3E'">
                                <span style="color: #e5e5e5; font-weight: 500;">${escapeHtml(profile.username || 'User')}</span>
                            </div>
                        `;
                    }
                    
                    html += `
                        <tr>
                            <td>${userHtml}</td>
                            <td>${stars} (${review.rating || 0}/5)</td>
                            <td>${escapeHtml(review.review || 'No review text')}</td>
                            <td>${date.toLocaleString()}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-delete" onclick="deleteReview('${id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                }

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading reviews:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading reviews</div></div>';
            }
        }

        // Delete review
        async function deleteReview(id) {
            if (!confirm('Are you sure you want to delete this review?')) return;

            try {
                await database.ref(`ratings/${id}`).remove();
                alert('‚úÖ Review deleted successfully!');
                loadReviews();
            } catch (error) {
                console.error('Error deleting review:', error);
                alert('‚ùå Failed to delete review: ' + error.message);
            }
        }

        // Load users
        async function loadUsers() {
            const content = document.getElementById('usersContent');
            try {
                // Load visits
                const visitsSnapshot = await database.ref('visits').once('value');
                // Load blacklist
                const blacklistSnapshot = await database.ref('blacklist').once('value');
                
                const blacklist = blacklistSnapshot.exists() ? blacklistSnapshot.val() : {};
                const visits = visitsSnapshot.exists() ? visitsSnapshot.val() : {};

                // Group visits by IP
                const usersByIP = {};
                Object.entries(visits).forEach(([visitId, visit]) => {
                    const ip = visit.ip || 'unknown';
                    if (!usersByIP[ip]) {
                        usersByIP[ip] = {
                            ip: ip,
                            visits: [],
                            firstVisit: visit.timestamp,
                            lastVisit: visit.timestamp,
                            userAgent: visit.userAgent
                        };
                    }
                    usersByIP[ip].visits.push(visit);
                    if (visit.timestamp < usersByIP[ip].firstVisit) {
                        usersByIP[ip].firstVisit = visit.timestamp;
                    }
                    if (visit.timestamp > usersByIP[ip].lastVisit) {
                        usersByIP[ip].lastVisit = visit.timestamp;
                    }
                });

                const users = Object.values(usersByIP).sort((a, b) => b.lastVisit - a.lastVisit);

                if (users.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üë§</div><div class="empty-state-text">No users yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>Visits</th>
                                <th>First Visit</th>
                                <th>Last Visit</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                users.forEach(user => {
                    const ipKey = user.ip.replace(/\./g, '_');
                    const isBlacklisted = blacklist[ipKey] !== undefined;
                    const firstDate = new Date(user.firstVisit).toLocaleString();
                    const lastDate = new Date(user.lastVisit).toLocaleString();
                    
                    html += `
                        <tr>
                            <td>${escapeHtml(user.ip)}</td>
                            <td>${user.visits.length}</td>
                            <td>${firstDate}</td>
                            <td>${lastDate}</td>
                            <td>
                                <span class="status-badge ${isBlacklisted ? 'status-blacklisted' : 'status-active'}">
                                    ${isBlacklisted ? 'Blacklisted' : 'Active'}
                                </span>
                            </td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="viewUser('${escapeHtml(user.ip)}')">View</button>
                                    ${isBlacklisted 
                                        ? `<button class="btn-action btn-unblacklist" onclick="unblacklistUser('${escapeHtml(user.ip)}')">Unblacklist</button>`
                                        : `<button class="btn-action btn-blacklist" onclick="openBlacklistModal('${escapeHtml(user.ip)}')">Blacklist</button>`
                                    }
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading users:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading users</div></div>';
            }
        }

        // View user
        async function viewUser(ip) {
            try {
                const visitsSnapshot = await database.ref('visits').once('value');
                const visits = visitsSnapshot.exists() ? visitsSnapshot.val() : {};
                const userVisits = Object.values(visits).filter(v => v.ip === ip);
                const blacklistSnapshot = await database.ref('blacklist').once('value');
                const blacklist = blacklistSnapshot.exists() ? blacklistSnapshot.val() : {};
                const ipKey = ip.replace(/\./g, '_');
                const isBlacklisted = blacklist[ipKey] !== undefined;

                let html = `
                    <div class="info-row">
                        <span class="info-label">IP Address:</span>
                        <span class="info-value">${escapeHtml(ip)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value">
                            <span class="status-badge ${isBlacklisted ? 'status-blacklisted' : 'status-active'}">
                                ${isBlacklisted ? 'Blacklisted' : 'Active'}
                            </span>
                        </span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Total Visits:</span>
                        <span class="info-value">${userVisits.length}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">First Visit:</span>
                        <span class="info-value">${new Date(userVisits[0]?.timestamp || 0).toLocaleString()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Last Visit:</span>
                        <span class="info-value">${new Date(userVisits[userVisits.length - 1]?.timestamp || 0).toLocaleString()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">User Agent:</span>
                        <span class="info-value" style="font-size: 12px; word-break: break-all;">${escapeHtml(userVisits[0]?.userAgent || 'Unknown')}</span>
                    </div>
                `;

                document.getElementById('userInfoContent').innerHTML = html;
                document.getElementById('userInfoModal').classList.add('active');
            } catch (error) {
                console.error('Error viewing user:', error);
                alert('Error loading user information');
            }
        }

        // Open blacklist modal
        window.openBlacklistModal = function(ip) {
            document.getElementById('blacklistIpInput').value = ip;
            document.getElementById('blacklistReasonInput').value = 'Other';
            document.getElementById('blacklistNotesInput').value = '';
            document.getElementById('blacklistError').style.display = 'none';
            document.getElementById('blacklistEditorTitle').textContent = 'Blacklist User';
            document.getElementById('blacklistEditorModal').classList.add('active');
            window.currentBlacklistingIp = ip;
        };

        // Close blacklist modal
        window.closeBlacklistModal = function() {
            const modal = document.getElementById('blacklistEditorModal');
            if (modal) {
                modal.classList.remove('active');
            }
            window.currentBlacklistingIp = null;
        };

        // Save blacklist
        window.saveBlacklist = async function() {
            const ipInput = document.getElementById('blacklistIpInput');
            const reasonInput = document.getElementById('blacklistReasonInput');
            const notesInput = document.getElementById('blacklistNotesInput');
            const errorDiv = document.getElementById('blacklistError');

            if (!ipInput || !reasonInput || !notesInput || !errorDiv) {
                alert('Error: Blacklist form elements not found. Please refresh the page.');
                return;
            }

            const ip = ipInput.value.trim();
            const reason = reasonInput.value;
            const notes = notesInput.value.trim();

            if (!ip) {
                errorDiv.textContent = 'IP address is required';
                errorDiv.style.display = 'block';
                return;
            }

            if (!reason) {
                errorDiv.textContent = 'Reason is required';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const ipKey = ip.replace(/\./g, '_');
                const blacklistData = {
                    ip: ip,
                    timestamp: Date.now(),
                    date: new Date().toISOString(),
                    reason: reason,
                    notes: notes || null,
                    blacklistedBy: 'admin'
                };

                await database.ref(`blacklist/${ipKey}`).set(blacklistData);
                alert('‚úÖ User blacklisted successfully!');
                window.closeBlacklistModal();
                loadUsers();
                if (document.getElementById('tabBlacklisted').style.display !== 'none') {
                    loadBlacklistedUsers();
                }
            } catch (error) {
                console.error('Error blacklisting user:', error);
                errorDiv.textContent = 'Failed to blacklist: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // Unblacklist user
        window.unblacklistUser = async function(ip) {
            if (!confirm(`Are you sure you want to unblacklist IP: ${ip}?`)) return;

            try {
                const ipKey = ip.replace(/\./g, '_');
                await database.ref(`blacklist/${ipKey}`).remove();
                alert('‚úÖ User unblacklisted successfully!');
                loadUsers();
                if (document.getElementById('tabBlacklisted').style.display !== 'none') {
                    loadBlacklistedUsers();
                }
            } catch (error) {
                console.error('Error unblacklisting user:', error);
                alert('‚ùå Failed to unblacklist user: ' + error.message);
            }
        }

        // Load blacklisted users
        async function loadBlacklistedUsers() {
            const content = document.getElementById('blacklistedContent');
            try {
                const snapshot = await database.ref('blacklist').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üö´</div><div class="empty-state-text">No blacklisted users</div></div>';
                    return;
                }

                const blacklist = snapshot.val();
                const entries = Object.entries(blacklist);

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üö´</div><div class="empty-state-text">No blacklisted users</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>Reason</th>
                                <th>Blacklisted Date</th>
                                <th>Notes</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(([id, entry]) => {
                    const date = new Date(entry.timestamp || 0).toLocaleString();
                    html += `
                        <tr>
                            <td>${escapeHtml(entry.ip || id.replace(/_/g, '.'))}</td>
                            <td><span class="status-badge status-blacklisted">${escapeHtml(entry.reason || 'Unknown')}</span></td>
                            <td>${date}</td>
                            <td>${escapeHtml(entry.notes || 'No notes')}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="viewBlacklistedUser('${escapeHtml(entry.ip || id.replace(/_/g, '.'))}')">View</button>
                                    <button class="btn-action btn-unblacklist" onclick="unblacklistUser('${escapeHtml(entry.ip || id.replace(/_/g, '.'))}')">Unblacklist</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading blacklisted users:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading blacklisted users</div></div>';
            }
        }

        // View blacklisted user details
        async function viewBlacklistedUser(ip) {
            try {
                const ipKey = ip.replace(/\./g, '_');
                const snapshot = await database.ref(`blacklist/${ipKey}`).once('value');
                if (!snapshot.exists()) {
                    alert('Blacklist entry not found');
                    return;
                }

                const entry = snapshot.val();
                const visitsSnapshot = await database.ref('visits').once('value');
                const visits = visitsSnapshot.exists() ? visitsSnapshot.val() : {};
                const userVisits = Object.values(visits).filter(v => v.ip === ip);

                let html = `
                    <div class="info-row">
                        <span class="info-label">IP Address:</span>
                        <span class="info-value">${escapeHtml(ip)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value">
                            <span class="status-badge status-blacklisted">Blacklisted</span>
                        </span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Reason:</span>
                        <span class="info-value">${escapeHtml(entry.reason || 'Unknown')}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Blacklisted Date:</span>
                        <span class="info-value">${new Date(entry.timestamp || 0).toLocaleString()}</span>
                    </div>
                    ${entry.notes ? `
                    <div class="info-row">
                        <span class="info-label">Notes:</span>
                        <span class="info-value">${escapeHtml(entry.notes)}</span>
                    </div>
                    ` : ''}
                    <div class="info-row">
                        <span class="info-label">Total Visits Before Blacklist:</span>
                        <span class="info-value">${userVisits.length}</span>
                    </div>
                    ${userVisits.length > 0 ? `
                    <div class="info-row">
                        <span class="info-label">Last Visit:</span>
                        <span class="info-value">${new Date(userVisits[userVisits.length - 1]?.timestamp || 0).toLocaleString()}</span>
                    </div>
                    ` : ''}
                `;

                document.getElementById('userInfoContent').innerHTML = html;
                document.getElementById('userInfoModal').classList.add('active');
            } catch (error) {
                console.error('Error viewing blacklisted user:', error);
                alert('Error loading user information');
            }
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // Logout
        function logout() {
            // Clear user session
            localStorage.removeItem(USER_PROFILE_ID_KEY);
            localStorage.removeItem('recon_auth_token');
            window.location.href = '/';
        }

        // Escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Load announcements
        async function loadAnnouncements() {
            const content = document.getElementById('announcementsContent');
            try {
                const snapshot = await database.ref('announcements').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì¢</div><div class="empty-state-text">No announcements yet</div></div>';
                    return;
                }

                const announcements = snapshot.val();
                const entries = Object.entries(announcements);

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì¢</div><div class="empty-state-text">No announcements yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Title</th>
                                <th>Type</th>
                                <th>Priority</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(([id, announcement]) => {
                    html += `
                        <tr>
                            <td>${escapeHtml(announcement.title || 'Untitled')}</td>
                            <td><span class="status-badge status-active">${announcement.type || 'info'}</span></td>
                            <td><span class="status-badge status-active">${announcement.priority || 'medium'}</span></td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="editAnnouncement('${id}')">Edit</button>
                                    <button class="btn-action btn-delete" onclick="deleteAnnouncement('${id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading announcements:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading announcements</div></div>';
            }
        }

        // Load changelog
        async function loadChangelog() {
            const content = document.getElementById('changelogContent');
            try {
                const snapshot = await database.ref('changelog').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìù</div><div class="empty-state-text">No changelog entries yet</div></div>';
                    return;
                }

                const changelog = snapshot.val();
                const entries = Object.entries(changelog);

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìù</div><div class="empty-state-text">No changelog entries yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Version</th>
                                <th>Date</th>
                                <th>Changes</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(([id, entry]) => {
                    html += `
                        <tr>
                            <td>${escapeHtml(entry.version || 'Unknown')}</td>
                            <td>${escapeHtml(entry.date || '')}</td>
                            <td>${(entry.changes || []).length} changes</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="editChangelog('${id}')">Edit</button>
                                    <button class="btn-action btn-delete" onclick="deleteChangelog('${id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading changelog:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading changelog</div></div>';
            }
        }

        // Announcement editor functions
        let changelogChanges = [];
        window.currentEditingAnnouncementId = null;
        window.currentEditingChangelogId = null;

        window.editAnnouncement = async function(id) {
            const modal = document.getElementById('announcementEditorModal');
            const title = document.getElementById('announcementEditorTitle');
            const titleInput = document.getElementById('announcementTitleInput');
            const messageInput = document.getElementById('announcementMessageInput');
            const typeInput = document.getElementById('announcementTypeInput');
            const priorityInput = document.getElementById('announcementPriorityInput');
            const endDateInput = document.getElementById('announcementEndDateInput');
            const dismissibleInput = document.getElementById('announcementDismissibleInput');
            const linkInput = document.getElementById('announcementLinkInput');
            const linkTextInput = document.getElementById('announcementLinkTextInput');
            const errorDiv = document.getElementById('announcementEditorError');

            if (!modal) return;

            // Clear form
            titleInput.value = '';
            messageInput.value = '';
            typeInput.value = 'info';
            priorityInput.value = 'medium';
            endDateInput.value = '';
            dismissibleInput.checked = true;
            linkInput.value = '';
            linkTextInput.value = '';
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';

            if (id) {
                title.textContent = 'Edit Announcement';
                try {
                    const snapshot = await database.ref(`announcements/${id}`).once('value');
                    if (snapshot.exists()) {
                        const announcement = snapshot.val();
                        titleInput.value = announcement.title || '';
                        messageInput.value = announcement.message || '';
                        typeInput.value = announcement.type || 'info';
                        priorityInput.value = announcement.priority || 'medium';
                        if (announcement.endDate) {
                            const endDate = new Date(announcement.endDate);
                            endDateInput.value = endDate.toISOString().slice(0, 16);
                        }
                        dismissibleInput.checked = announcement.dismissible !== false;
                        linkInput.value = announcement.link || '';
                        linkTextInput.value = announcement.linkText || '';
                    }
                } catch (error) {
                    console.error('Error loading announcement:', error);
                    errorDiv.textContent = 'Failed to load announcement';
                    errorDiv.style.display = 'block';
                }
            } else {
                title.textContent = 'Add Announcement';
            }

            modal.classList.add('active');
            window.currentEditingAnnouncementId = id;
        };

        window.hideAnnouncementEditor = function() {
            const modal = document.getElementById('announcementEditorModal');
            if (modal) {
                modal.classList.remove('active');
            }
            window.currentEditingAnnouncementId = null;
        };

        window.saveAnnouncement = async function() {
            const titleInput = document.getElementById('announcementTitleInput');
            const messageInput = document.getElementById('announcementMessageInput');
            const typeInput = document.getElementById('announcementTypeInput');
            const priorityInput = document.getElementById('announcementPriorityInput');
            const endDateInput = document.getElementById('announcementEndDateInput');
            const dismissibleInput = document.getElementById('announcementDismissibleInput');
            const linkInput = document.getElementById('announcementLinkInput');
            const linkTextInput = document.getElementById('announcementLinkTextInput');
            const errorDiv = document.getElementById('announcementEditorError');

            if (!titleInput.value.trim()) {
                errorDiv.textContent = 'Title is required';
                errorDiv.style.display = 'block';
                return;
            }
            if (!messageInput.value.trim()) {
                errorDiv.textContent = 'Message is required';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const announcementData = {
                    title: titleInput.value.trim(),
                    message: messageInput.value.trim(),
                    type: typeInput.value,
                    priority: priorityInput.value,
                    dismissible: dismissibleInput.checked
                };

                if (endDateInput.value) {
                    announcementData.endDate = new Date(endDateInput.value).getTime();
                }
                if (linkInput.value.trim()) {
                    announcementData.link = linkInput.value.trim();
                    announcementData.linkText = linkTextInput.value.trim() || 'Learn More';
                }

                const id = window.currentEditingAnnouncementId || 'announcement_' + Date.now();
                await database.ref(`announcements/${id}`).set(announcementData);
                
                alert('‚úÖ Announcement saved!');
                hideAnnouncementEditor();
                loadAnnouncements();
            } catch (error) {
                console.error('Error saving announcement:', error);
                errorDiv.textContent = 'Failed to save: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        window.deleteAnnouncement = async function(id) {
            if (!confirm('Are you sure you want to delete this announcement?')) return;
            try {
                await database.ref(`announcements/${id}`).remove();
                alert('‚úÖ Announcement deleted!');
                loadAnnouncements();
            } catch (error) {
                console.error('Error deleting announcement:', error);
                alert('‚ùå Failed to delete: ' + error.message);
            }
        };

        // Changelog editor functions
        window.editChangelog = async function(id) {
            const modal = document.getElementById('changelogEditorModal');
            const title = document.getElementById('changelogEditorTitle');
            const versionInput = document.getElementById('changelogVersionInput');
            const dateInput = document.getElementById('changelogDateInput');
            const typeInput = document.getElementById('changelogTypeInput');
            const downloadUrlInput = document.getElementById('changelogDownloadUrlInput');
            const changesList = document.getElementById('changelogChangesList');
            const errorDiv = document.getElementById('changelogEditorError');

            if (!modal) return;

            changelogChanges = [];
            versionInput.value = '';
            dateInput.value = '';
            typeInput.value = '';
            downloadUrlInput.value = '';
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
            renderChangelogChanges();

            if (id) {
                title.textContent = 'Edit Changelog Entry';
                try {
                    const snapshot = await database.ref(`changelog/${id}`).once('value');
                    if (snapshot.exists()) {
                        const entry = snapshot.val();
                        versionInput.value = entry.version || '';
                        if (entry.date) {
                            const dateObj = new Date(entry.date);
                            if (!isNaN(dateObj.getTime())) {
                                dateInput.value = dateObj.toISOString().split('T')[0];
                            }
                        }
                        typeInput.value = entry.type || '';
                        downloadUrlInput.value = entry.downloadUrl || '';
                        changelogChanges = Array.isArray(entry.changes) ? [...entry.changes] : [];
                        renderChangelogChanges();
                    }
                } catch (error) {
                    console.error('Error loading changelog:', error);
                    errorDiv.textContent = 'Failed to load changelog entry';
                    errorDiv.style.display = 'block';
                }
            } else {
                title.textContent = 'Add Changelog Entry';
                const today = new Date();
                dateInput.value = today.toISOString().split('T')[0];
            }

            modal.classList.add('active');
            window.currentEditingChangelogId = id;
        };

        window.hideChangelogEditor = function() {
            const modal = document.getElementById('changelogEditorModal');
            if (modal) {
                modal.classList.remove('active');
            }
            window.currentEditingChangelogId = null;
            changelogChanges = [];
        };

        function renderChangelogChanges() {
            const changesList = document.getElementById('changelogChangesList');
            if (!changesList) return;

            if (changelogChanges.length === 0) {
                changesList.innerHTML = '<div style="color: #888; font-size: 13px; padding: 8px;">No changes added yet</div>';
                return;
            }

            changesList.innerHTML = changelogChanges.map((change, index) => `
                <div class="changelog-change-item">
                    <span class="changelog-change-item-text">${escapeHtml(change)}</span>
                    <button type="button" class="changelog-change-item-remove" onclick="removeChangelogChange(${index})">Remove</button>
                </div>
            `).join('');
        }

        window.addChangelogChange = function() {
            const changeInput = document.getElementById('changelogChangeInput');
            if (!changeInput) return;
            const change = changeInput.value.trim();
            if (!change) return;
            changelogChanges.push(change);
            changeInput.value = '';
            renderChangelogChanges();
        };

        window.removeChangelogChange = function(index) {
            changelogChanges.splice(index, 1);
            renderChangelogChanges();
        };

        window.saveChangelog = async function() {
            const versionInput = document.getElementById('changelogVersionInput');
            const dateInput = document.getElementById('changelogDateInput');
            const typeInput = document.getElementById('changelogTypeInput');
            const downloadUrlInput = document.getElementById('changelogDownloadUrlInput');
            const errorDiv = document.getElementById('changelogEditorError');

            if (!versionInput.value.trim()) {
                errorDiv.textContent = 'Version is required';
                errorDiv.style.display = 'block';
                return;
            }
            if (!dateInput.value) {
                errorDiv.textContent = 'Release date is required';
                errorDiv.style.display = 'block';
                return;
            }
            if (changelogChanges.length === 0) {
                errorDiv.textContent = 'At least one change is required';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const dateObj = new Date(dateInput.value);
                const date = dateObj.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                
                const changelogData = {
                    version: versionInput.value.trim(),
                    date: date,
                    changes: changelogChanges.filter(c => c.trim().length > 0)
                };

                if (typeInput.value.trim()) {
                    changelogData.type = typeInput.value.trim();
                }
                if (downloadUrlInput.value.trim()) {
                    changelogData.downloadUrl = downloadUrlInput.value.trim();
                }

                const id = window.currentEditingChangelogId || 'v' + versionInput.value.replace(/\./g, '_') + '_' + Date.now();
                await database.ref(`changelog/${id}`).set(changelogData);

                alert('‚úÖ Changelog saved!');
                hideChangelogEditor();
                loadChangelog();
            } catch (error) {
                console.error('Error saving changelog:', error);
                errorDiv.textContent = 'Failed to save: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        window.deleteChangelog = async function(id) {
            if (!confirm('Are you sure you want to delete this changelog entry?')) return;
            try {
                await database.ref(`changelog/${id}`).remove();
                alert('‚úÖ Changelog deleted!');
                loadChangelog();
            } catch (error) {
                console.error('Error deleting changelog:', error);
                alert('‚ùå Failed to delete: ' + error.message);
            }
        };

        // Tab switching
        document.querySelectorAll('.admin-tab').forEach(tab => {
            tab.addEventListener('click', async () => {
                const tabName = tab.getAttribute('data-tab');
                
                    // Check access level for granted users
                    const access = await getUserAccessLevel();
                    if (access && access.level === 'granted') {
                        const allowedTabs = ['keys'];
                        if (access.canGrant) {
                            allowedTabs.push('grant');
                        }
                        if (!allowedTabs.includes(tabName)) {
                            alert(`You only have access to the ${allowedTabs.map(t => t === 'keys' ? 'License Keys' : 'Grant').join(' and ')} tab${allowedTabs.length > 1 ? 's' : ''}.`);
                            return;
                        }
                    }
                
                // Update tab buttons
                document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update content
                document.querySelectorAll('.admin-content-card').forEach(c => c.style.display = 'none');
                // Map tab names to content IDs (handle camelCase)
                const tabIdMap = {
                    'announcements': 'tabAnnouncements',
                    'changelog': 'tabChangelog',
                    'reviews': 'tabReviews',
                    'users': 'tabUsers',
                    'blacklisted': 'tabBlacklisted',
                    'maintenance': 'tabMaintenance',
                    'backup': 'tabBackup',
                    'surveys': 'tabSurveys',
                    'webhooks': 'tabWebhooks',
                    'tickets': 'tabTickets',
                    'profiles': 'tabProfiles',
                    'keys': 'tabKeys',
                    'finalReseller': 'tabFinalReseller',
                    'grant': 'tabGrant',
                    'ownerManagement': 'tabOwnerManagement'
                };
                const tabContentId = tabIdMap[tabName] || (`tab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
                const tabContent = document.getElementById(tabContentId);
                if (tabContent) {
                    tabContent.style.display = 'block';
                }
                
                // Load data for active tab
                if (tabName === 'announcements') {
                    loadAnnouncements();
                } else if (tabName === 'changelog') {
                    loadChangelog();
                } else if (tabName === 'reviews') {
                    loadReviews();
                } else if (tabName === 'users') {
                    loadUsers();
                } else if (tabName === 'maintenance') {
                    loadMaintenanceSettings();
                } else if (tabName === 'backup') {
                    loadBackupTools();
                } else if (tabName === 'surveys') {
                    loadSurveys();
                } else if (tabName === 'webhooks') {
                    loadWebhooks();
                } else if (tabName === 'tickets') {
                    loadTickets();
                } else if (tabName === 'profiles') {
                    loadUserProfiles();
                } else if (tabName === 'keys') {
                    loadKeys(false); // Don't auto-sync on tab open to prevent false positives
                } else if (tabName === 'finalReseller') {
                    loadFinalReseller();
                } else if (tabName === 'grant') {
                    loadUsersForGrant();
                    loadGrantedUsers();
                } else if (tabName === 'ownerManagement') {
                    loadOwnerManagement();
                }
            });
        });

        // ============================================
        // MAINTENANCE MODE
        // ============================================
        async function loadMaintenanceSettings() {
            const content = document.getElementById('maintenanceContent');
            try {
                const snapshot = await database.ref('maintenance').once('value');
                const maintenance = snapshot.exists() ? snapshot.val() : { enabled: false, message: '', returnTime: null };

                let html = `
                    <div style="background: ${maintenance.enabled ? 'rgba(239, 68, 68, 0.1)' : 'rgba(34, 197, 94, 0.1)'}; border: 1px solid ${maintenance.enabled ? 'rgba(239, 68, 68, 0.3)' : 'rgba(34, 197, 94, 0.3)'}; border-radius: 12px; padding: 20px; margin-bottom: 30px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                            <div>
                                <h3 style="color: #e5e5e5; margin-bottom: 5px;">Status: <span style="color: ${maintenance.enabled ? '#ef4444' : '#22c55e'}">${maintenance.enabled ? 'ENABLED' : 'DISABLED'}</span></h3>
                                ${maintenance.enabled ? '<p style="color: #888; font-size: 13px;">Site is currently in maintenance mode</p>' : '<p style="color: #888; font-size: 13px;">Site is accessible to all users</p>'}
                            </div>
                            <button class="admin-btn ${maintenance.enabled ? 'admin-btn-danger' : 'admin-btn-primary'}" onclick="openMaintenanceModal()">
                                ${maintenance.enabled ? '‚öôÔ∏è Configure' : 'üîß Enable Maintenance'}
                            </button>
                        </div>
                        ${maintenance.enabled ? `
                            <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 15px; margin-top: 15px;">
                                <p style="color: #e5e5e5; margin-bottom: 10px;"><strong>Message:</strong></p>
                                <p style="color: #888; margin-bottom: 10px;">${escapeHtml(maintenance.message || 'No message set')}</p>
                                ${maintenance.returnTime ? `<p style="color: #888; font-size: 12px;">Estimated return: ${new Date(maintenance.returnTime).toLocaleString()}</p>` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 12px; padding: 20px;">
                        <h4 style="color: #e5e5e5; margin-bottom: 10px;">‚ÑπÔ∏è About Maintenance Mode</h4>
                        <ul style="color: #888; font-size: 14px; line-height: 1.8; padding-left: 20px;">
                            <li>When enabled, all users (except admins) will see a maintenance page</li>
                            <li>You can customize the message shown to users</li>
                            <li>Set an estimated return time to inform users when the site will be back</li>
                            <li>Admin panel remains accessible during maintenance</li>
                        </ul>
                    </div>
                `;

                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading maintenance settings:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading maintenance settings</div></div>';
            }
        }

        window.openMaintenanceModal = function() {
            database.ref('maintenance').once('value').then(snapshot => {
                const maintenance = snapshot.exists() ? snapshot.val() : { enabled: false, message: '', returnTime: null };
                const enabledCheckbox = document.getElementById('maintenanceEnabled');
                const messageInput = document.getElementById('maintenanceMessage');
                const returnTimeInput = document.getElementById('maintenanceReturnTime');
                const modal = document.getElementById('maintenanceModal');
                
                if (!enabledCheckbox || !messageInput || !returnTimeInput || !modal) {
                    console.error('Maintenance modal elements not found');
                    alert('Error: Maintenance modal not found. Please refresh the page.');
                    return;
                }
                
                enabledCheckbox.checked = maintenance.enabled || false;
                messageInput.value = maintenance.message || 'We\'re currently performing scheduled maintenance. We\'ll be back shortly!';
                if (maintenance.returnTime) {
                    const returnDate = new Date(maintenance.returnTime);
                    returnTimeInput.value = returnDate.toISOString().slice(0, 16);
                } else {
                    returnTimeInput.value = '';
                }
                modal.classList.add('active');
            }).catch(error => {
                console.error('Error loading maintenance settings:', error);
                alert('Error loading maintenance settings: ' + error.message);
            });
        }

        window.closeMaintenanceModal = function() {
            const modal = document.getElementById('maintenanceModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function toggleMaintenancePreview() {
            // Could add preview functionality here
        }

        window.saveMaintenanceSettings = async function() {
            const enabledCheckbox = document.getElementById('maintenanceEnabled');
            const messageInput = document.getElementById('maintenanceMessage');
            const returnTimeInput = document.getElementById('maintenanceReturnTime');
            const errorDiv = document.getElementById('maintenanceError');

            if (!enabledCheckbox || !messageInput || !returnTimeInput || !errorDiv) {
                alert('Error: Maintenance form elements not found. Please refresh the page.');
                return;
            }

            const enabled = enabledCheckbox.checked;
            const message = messageInput.value.trim();

            if (enabled && !message) {
                errorDiv.textContent = 'Message is required when maintenance mode is enabled';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const maintenanceData = {
                    enabled: enabled,
                    message: message,
                    updatedAt: Date.now(),
                    updatedBy: 'admin'
                };

                if (returnTimeInput.value) {
                    maintenanceData.returnTime = new Date(returnTimeInput.value).getTime();
                } else {
                    maintenanceData.returnTime = null;
                }

                await database.ref('maintenance').set(maintenanceData);
                alert('‚úÖ Maintenance settings saved!');
                closeMaintenanceModal();
                loadMaintenanceSettings();
            } catch (error) {
                console.error('Error saving maintenance settings:', error);
                errorDiv.textContent = 'Failed to save: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        // ============================================
        // BACKUP & RESTORE
        // ============================================
        async function loadBackupTools() {
            const content = document.getElementById('backupContent');
            
            // Load backup history
            let backupHistory = [];
            try {
                const snapshot = await database.ref('backups').once('value');
                if (snapshot.exists()) {
                    backupHistory = Object.entries(snapshot.val())
                        .map(([id, backup]) => ({ id, ...backup }))
                        .sort((a, b) => b.timestamp - a.timestamp)
                        .slice(0, 10); // Show last 10 backups
                }
            } catch (error) {
                console.error('Error loading backup history:', error);
            }

            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 12px; padding: 24px;">
                        <div style="font-size: 32px; margin-bottom: 12px;">üíæ</div>
                        <h3 style="color: #e5e5e5; margin-bottom: 8px;">Create Backup</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 16px;">Export all database data to a JSON file</p>
                        <button class="admin-btn admin-btn-primary" onclick="createBackup()" style="width: 100%;">Create Backup Now</button>
                    </div>
                    <div style="background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(34, 197, 94, 0.05) 100%); border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 12px; padding: 24px;">
                        <div style="font-size: 32px; margin-bottom: 12px;">üì§</div>
                        <h3 style="color: #e5e5e5; margin-bottom: 8px;">Restore Backup</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 16px;">Import data from a JSON backup file</p>
                        <button class="admin-btn" onclick="restoreBackup()" style="width: 100%; background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.3); color: #22c55e;">Restore from File</button>
                    </div>
                </div>

                <div style="background: rgba(26, 26, 26, 0.5); border: 1px solid rgba(74, 74, 74, 0.5); border-radius: 12px; padding: 20px;">
                    <h3 style="color: #e5e5e5; margin-bottom: 15px;">Backup History</h3>
            `;

            if (backupHistory.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-text">No backups created yet</div></div>';
            } else {
                html += `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Size</th>
                                <th>Items</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                backupHistory.forEach(backup => {
                    const date = new Date(backup.timestamp);
                    html += `
                        <tr>
                            <td>${date.toLocaleString()}</td>
                            <td>${formatBytes(backup.size || 0)}</td>
                            <td>${backup.itemCount || 0} items</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="downloadBackup('${backup.id}')">Download</button>
                                    <button class="btn-action btn-delete" onclick="deleteBackup('${backup.id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
            }

            html += '</div>';

            content.innerHTML = html;
        }

        async function createBackup() {
            if (!confirm('Create a backup of all database data? This may take a moment.')) return;

            try {
                const data = {
                    announcements: {},
                    changelog: {},
                    downloads: {},
                    ratings: {},
                    translations: {},
                    visits: {},
                    blacklist: {},
                    maintenance: {}
                };

                // Try to read each path individually to handle permission errors gracefully
                const paths = [
                    { key: 'announcements', ref: database.ref('announcements') },
                    { key: 'changelog', ref: database.ref('changelog') },
                    { key: 'downloads', ref: database.ref('downloads') },
                    { key: 'ratings', ref: database.ref('ratings') },
                    { key: 'translations', ref: database.ref('translations') },
                    { key: 'visits', ref: database.ref('visits') },
                    { key: 'blacklist', ref: database.ref('blacklist') },
                    { key: 'maintenance', ref: database.ref('maintenance') }
                ];

                for (const path of paths) {
                    try {
                        const snapshot = await path.ref.once('value');
                        if (snapshot.exists()) {
                            data[path.key] = snapshot.val();
                        }
                    } catch (error) {
                        console.warn(`Warning: Could not backup ${path.key}:`, error.message);
                        // Continue with other paths even if one fails
                    }
                }

                const jsonData = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                a.download = `recon-backup-${timestamp}.json`;
                a.click();
                URL.revokeObjectURL(url);

                // Save backup record
                const backupId = 'backup_' + Date.now();
                const itemCount = Object.values(data).reduce((sum, section) => sum + Object.keys(section).length, 0);
                await database.ref(`backups/${backupId}`).set({
                    timestamp: Date.now(),
                    size: blob.size,
                    itemCount: itemCount,
                    createdBy: 'admin'
                });

                alert('‚úÖ Backup created and downloaded successfully!');
                loadBackupTools();
            } catch (error) {
                console.error('Backup error:', error);
                alert('‚ùå Failed to create backup: ' + error.message);
            }
        }

        async function restoreBackup() {
            if (!confirm('‚ö†Ô∏è WARNING: This will overwrite all existing data. Are you sure you want to continue?')) return;
            if (!confirm('‚ö†Ô∏è This action cannot be undone. Continue?')) return;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // Validate backup structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid backup file format');
                    }

                    // Show progress
                    const progress = confirm('Restoring backup... This may take a moment. Click OK to continue.');
                    if (!progress) return;

                    // Restore data
                    if (data.announcements) await database.ref('announcements').set(data.announcements);
                    if (data.changelog) await database.ref('changelog').set(data.changelog);
                    if (data.downloads) await database.ref('downloads').set(data.downloads);
                    if (data.ratings) await database.ref('ratings').set(data.ratings);
                    if (data.translations) await database.ref('translations').set(data.translations);
                    if (data.visits) await database.ref('visits').set(data.visits);
                    if (data.blacklist) await database.ref('blacklist').set(data.blacklist);
                    if (data.maintenance) await database.ref('maintenance').set(data.maintenance);

                    alert('‚úÖ Backup restored successfully! The page will reload.');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } catch (error) {
                    console.error('Restore error:', error);
                    alert('‚ùå Failed to restore backup: ' + error.message);
                }
            };
            input.click();
        }

        async function downloadBackup(backupId) {
            // This would download a specific backup from storage
            // For now, just create a new backup
            alert('Downloading backup...');
            createBackup();
        }

        async function deleteBackup(backupId) {
            if (!confirm('Delete this backup record?')) return;
            try {
                await database.ref(`backups/${backupId}`).remove();
                alert('‚úÖ Backup record deleted!');
                loadBackupTools();
            } catch (error) {
                console.error('Error deleting backup:', error);
                alert('‚ùå Failed to delete: ' + error.message);
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            trackUserVisit();
            loadAnnouncements();
            
            // Close modals on outside click
            document.getElementById('announcementEditorModal').addEventListener('click', (e) => {
                if (e.target.id === 'announcementEditorModal') {
                    hideAnnouncementEditor();
                }
            });
            
            document.getElementById('changelogEditorModal').addEventListener('click', (e) => {
                if (e.target.id === 'changelogEditorModal') {
                    hideChangelogEditor();
                }
            });
            
            document.getElementById('maintenanceModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'maintenanceModal') {
                    closeMaintenanceModal();
                }
            });
            
            document.getElementById('blacklistEditorModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'blacklistEditorModal') {
                    closeBlacklistModal();
                }
            });
            
            // Enter key for changelog changes
            document.getElementById('changelogChangeInput')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addChangelogChange();
                }
            });
        });

        // Close modal on outside click
        document.getElementById('userInfoModal').addEventListener('click', (e) => {
            if (e.target.id === 'userInfoModal') {
                closeModal('userInfoModal');
            }
        });

        // ============================================
        // SURVEYS & POLLS FUNCTIONS
        // ============================================
        let surveyOptions = [];

        async function loadSurveys() {
            const content = document.getElementById('surveysContent');
            try {
                const snapshot = await database.ref('surveys').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No surveys created yet</div></div>';
                    return;
                }

                const surveys = snapshot.val();
                const entries = Object.entries(surveys);

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No surveys created yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Title</th>
                                <th>Type</th>
                                <th>Options</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(([id, survey]) => {
                    html += `
                        <tr>
                            <td>${escapeHtml(survey.title || 'Untitled')}</td>
                            <td><span class="status-badge ${survey.type === 'poll' ? 'status-active' : survey.type === 'survey' ? 'status-warning' : 'status-info'}">${survey.type || 'poll'}</span></td>
                            <td>${survey.options ? survey.options.length : 0} options</td>
                            <td><span class="status-badge ${survey.active ? 'status-active' : 'status-inactive'}">${survey.active ? 'Active' : 'Inactive'}</span></td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="editSurvey('${id}')">Edit</button>
                                    <button class="btn-action btn-delete" onclick="deleteSurvey('${id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading surveys:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading surveys</div></div>';
            }
        }

        window.editSurvey = async function(id) {
            const modal = document.getElementById('surveyEditorModal');
            const title = document.getElementById('surveyEditorTitle');
            const titleInput = document.getElementById('surveyTitleInput');
            const descriptionInput = document.getElementById('surveyDescriptionInput');
            const typeInput = document.getElementById('surveyTypeInput');
            const activeInput = document.getElementById('surveyActiveInput');
            const errorDiv = document.getElementById('surveyEditorError');

            if (!modal) return;

            surveyOptions = [];
            titleInput.value = '';
            descriptionInput.value = '';
            typeInput.value = 'poll';
            activeInput.checked = true;
            errorDiv.style.display = 'none';
            renderSurveyOptions();

            if (id) {
                title.textContent = 'Edit Survey/Poll';
                try {
                    const snapshot = await database.ref(`surveys/${id}`).once('value');
                    if (snapshot.exists()) {
                        const survey = snapshot.val();
                        titleInput.value = survey.title || '';
                        descriptionInput.value = survey.description || '';
                        typeInput.value = survey.type || 'poll';
                        activeInput.checked = survey.active !== false;
                        surveyOptions = survey.options || [];
                        renderSurveyOptions();
                    }
                } catch (error) {
                    console.error('Error loading survey:', error);
                    alert('Error loading survey: ' + error.message);
                }
            } else {
                title.textContent = 'Create Survey/Poll';
            }

            modal.classList.add('active');
            window.currentEditingSurveyId = id || null;
        };

        window.hideSurveyEditor = function() {
            const modal = document.getElementById('surveyEditorModal');
            if (modal) {
                modal.classList.remove('active');
            }
            window.currentEditingSurveyId = null;
        };

        window.addSurveyOption = function() {
            const input = document.getElementById('surveyOptionInput');
            const option = input.value.trim();
            if (option && !surveyOptions.includes(option)) {
                surveyOptions.push(option);
                input.value = '';
                renderSurveyOptions();
            }
        };

        function removeSurveyOption(index) {
            surveyOptions.splice(index, 1);
            renderSurveyOptions();
        }

        function renderSurveyOptions() {
            const list = document.getElementById('surveyOptionsList');
            if (!list) return;

            if (surveyOptions.length === 0) {
                list.innerHTML = '<div style="color: #888; font-size: 13px; padding: 12px; background: rgba(26, 26, 26, 0.5); border-radius: 4px;">No options added yet</div>';
                return;
            }

            list.innerHTML = surveyOptions.map((option, index) => `
                <div style="display: flex; align-items: center; gap: 12px; padding: 8px; background: rgba(26, 26, 26, 0.5); border-radius: 4px; margin-bottom: 8px;">
                    <span style="flex: 1; color: #e5e5e5;">${escapeHtml(option)}</span>
                    <button type="button" class="btn-action btn-delete" onclick="removeSurveyOption(${index})" style="padding: 4px 8px;">Remove</button>
                </div>
            `).join('');
        }

        window.saveSurvey = async function() {
            const titleInput = document.getElementById('surveyTitleInput');
            const descriptionInput = document.getElementById('surveyDescriptionInput');
            const typeInput = document.getElementById('surveyTypeInput');
            const activeInput = document.getElementById('surveyActiveInput');
            const errorDiv = document.getElementById('surveyEditorError');

            const title = titleInput.value.trim();
            const description = descriptionInput.value.trim();
            const type = typeInput.value;
            const active = activeInput.checked;

            if (!title) {
                errorDiv.textContent = 'Title is required';
                errorDiv.style.display = 'block';
                return;
            }

            if (surveyOptions.length < 2) {
                errorDiv.textContent = 'At least 2 options are required';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const surveyData = {
                    title,
                    description: description || null,
                    type,
                    options: surveyOptions,
                    active,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                };

                const id = window.currentEditingSurveyId || 'survey_' + Date.now();
                await database.ref(`surveys/${id}`).set(surveyData);
                alert('‚úÖ Survey saved successfully!');
                hideSurveyEditor();
                loadSurveys();
            } catch (error) {
                console.error('Error saving survey:', error);
                errorDiv.textContent = 'Failed to save: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        window.deleteSurvey = async function(id) {
            if (!confirm('Are you sure you want to delete this survey?')) return;
            try {
                await database.ref(`surveys/${id}`).remove();
                alert('‚úÖ Survey deleted!');
                loadSurveys();
            } catch (error) {
                console.error('Error deleting survey:', error);
                alert('‚ùå Failed to delete: ' + error.message);
            }
        };

        // ============================================
        // DISCORD WEBHOOK FUNCTIONS
        // ============================================
        let embedFields = [];

        async function loadWebhooks() {
            const content = document.getElementById('webhooksContent');
            try {
                const snapshot = await database.ref('webhooks').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No webhooks created yet</div></div>';
                    return;
                }

                const webhooks = snapshot.val();
                const entries = Object.entries(webhooks);

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No webhooks created yet</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>URL</th>
                                <th>Last Sent</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(([id, webhook]) => {
                    const lastSent = webhook.lastSent ? new Date(webhook.lastSent).toLocaleString() : 'Never';
                    html += `
                        <tr>
                            <td>${escapeHtml(webhook.name || 'Unnamed')}</td>
                            <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(webhook.url || '')}</td>
                            <td>${lastSent}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="editWebhook('${id}')">Edit</button>
                                    <button class="btn-action btn-view" onclick="testWebhookById('${id}')">Test</button>
                                    <button class="btn-action btn-delete" onclick="deleteWebhook('${id}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading webhooks:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading webhooks</div></div>';
            }
        }

        window.createWebhook = function() {
            editWebhook(null);
        };

        window.editWebhook = async function(id) {
            const modal = document.getElementById('webhookEditorModal');
            const title = document.getElementById('webhookEditorTitle');
            const nameInput = document.getElementById('webhookNameInput');
            const urlInput = document.getElementById('webhookUrlInput');
            const errorDiv = document.getElementById('webhookEditorError');

            if (!modal) return;

            // Reset all fields
            nameInput.value = '';
            urlInput.value = '';
            document.getElementById('embedTitleInput').value = '';
            document.getElementById('embedDescriptionInput').value = '';
            document.getElementById('embedUrlInput').value = '';
            document.getElementById('embedColorInput').value = '#5865F2';
            document.getElementById('embedAuthorNameInput').value = '';
            document.getElementById('embedAuthorIconInput').value = '';
            document.getElementById('embedFooterInput').value = '';
            document.getElementById('embedFooterIconInput').value = '';
            document.getElementById('embedThumbnailInput').value = '';
            document.getElementById('embedImageInput').value = '';
            document.getElementById('embedTimestampInput').value = 'now';
            document.getElementById('embedTimestampCustomInput').style.display = 'none';
            embedFields = [];
            renderEmbedFields();
            errorDiv.style.display = 'none';
            updateEmbedPreview();

            if (id) {
                title.textContent = 'Edit Discord Webhook';
                try {
                    const snapshot = await database.ref(`webhooks/${id}`).once('value');
                    if (snapshot.exists()) {
                        const webhook = snapshot.val();
                        nameInput.value = webhook.name || '';
                        urlInput.value = webhook.url || '';
                        if (webhook.embed) {
                            document.getElementById('embedTitleInput').value = webhook.embed.title || '';
                            document.getElementById('embedDescriptionInput').value = webhook.embed.description || '';
                            document.getElementById('embedUrlInput').value = webhook.embed.url || '';
                            document.getElementById('embedColorInput').value = webhook.embed.color || '#5865F2';
                            document.getElementById('embedAuthorNameInput').value = webhook.embed.author?.name || '';
                            document.getElementById('embedAuthorIconInput').value = webhook.embed.author?.icon_url || '';
                            document.getElementById('embedFooterInput').value = webhook.embed.footer?.text || '';
                            document.getElementById('embedFooterIconInput').value = webhook.embed.footer?.icon_url || '';
                            document.getElementById('embedThumbnailInput').value = webhook.embed.thumbnail?.url || '';
                            document.getElementById('embedImageInput').value = webhook.embed.image?.url || '';
                            if (webhook.embed.timestamp) {
                                document.getElementById('embedTimestampInput').value = 'custom';
                                const date = new Date(webhook.embed.timestamp);
                                document.getElementById('embedTimestampCustomInput').value = date.toISOString().slice(0, 16);
                                document.getElementById('embedTimestampCustomInput').style.display = 'block';
                            } else {
                                document.getElementById('embedTimestampInput').value = 'now';
                            }
                            embedFields = webhook.embed.fields || [];
                            renderEmbedFields();
                        }
                        updateEmbedPreview();
                    }
                } catch (error) {
                    console.error('Error loading webhook:', error);
                    alert('Error loading webhook: ' + error.message);
                }
            } else {
                title.textContent = 'Create Discord Webhook';
            }

            modal.classList.add('active');
            window.currentEditingWebhookId = id || null;
        };

        window.hideWebhookEditor = function() {
            const modal = document.getElementById('webhookEditorModal');
            if (modal) {
                modal.classList.remove('active');
            }
            window.currentEditingWebhookId = null;
        };

        window.addEmbedField = function() {
            embedFields.push({ name: '', value: '', inline: false });
            renderEmbedFields();
        };

        function removeEmbedField(index) {
            embedFields.splice(index, 1);
            renderEmbedFields();
            updateEmbedPreview();
        }

        function renderEmbedFields() {
            const list = document.getElementById('embedFieldsList');
            if (!list) return;

            if (embedFields.length === 0) {
                list.innerHTML = '<div style="color: #888; font-size: 13px; padding: 12px; background: rgba(26, 26, 26, 0.5); border-radius: 4px;">No fields added yet</div>';
                return;
            }

            list.innerHTML = embedFields.map((field, index) => `
                <div style="background: rgba(26, 26, 26, 0.5); border-radius: 4px; padding: 12px; margin-bottom: 8px;">
                    <div style="display: flex; gap: 12px; margin-bottom: 8px; align-items: center;">
                        <input type="text" class="form-input" placeholder="Field Name" value="${escapeHtml(field.name || '')}" onchange="embedFields[${index}].name = this.value; updateEmbedPreview();" style="flex: 1;" maxlength="256">
                        <label style="display: flex; align-items: center; gap: 4px; color: #888; font-size: 12px;">
                            <input type="checkbox" ${field.inline ? 'checked' : ''} onchange="embedFields[${index}].inline = this.checked; updateEmbedPreview();"> Inline
                        </label>
                        <button type="button" class="btn-action btn-delete" onclick="removeEmbedField(${index})" style="padding: 4px 8px;">Remove</button>
                    </div>
                    <textarea class="form-input" placeholder="Field Value" rows="2" onchange="embedFields[${index}].value = this.value; updateEmbedPreview();" maxlength="1024">${escapeHtml(field.value || '')}</textarea>
                </div>
            `).join('');
        }

        window.updateEmbedPreview = function() {
            const preview = document.getElementById('embedPreview');
            if (!preview) return;

            const embed = buildEmbedObject();
            preview.innerHTML = renderEmbedPreview(embed);
        };

        function buildEmbedObject() {
            const timestampValue = document.getElementById('embedTimestampInput').value;
            let timestamp = null;
            if (timestampValue === 'now') {
                timestamp = new Date().toISOString();
            } else if (timestampValue === 'custom') {
                const customDate = document.getElementById('embedTimestampCustomInput').value;
                if (customDate) {
                    timestamp = new Date(customDate).toISOString();
                }
            }

            const colorHex = document.getElementById('embedColorInput').value;
            const color = parseInt(colorHex.replace('#', ''), 16);

            const embed = {
                title: document.getElementById('embedTitleInput').value || null,
                description: document.getElementById('embedDescriptionInput').value || null,
                url: document.getElementById('embedUrlInput').value || null,
                color: color,
                timestamp: timestamp,
                author: null,
                footer: null,
                thumbnail: null,
                image: null,
                fields: embedFields.filter(f => f.name && f.value).length > 0 ? embedFields.filter(f => f.name && f.value) : null
            };

            const authorName = document.getElementById('embedAuthorNameInput').value;
            const authorIcon = document.getElementById('embedAuthorIconInput').value;
            if (authorName || authorIcon) {
                embed.author = {
                    name: authorName || null,
                    icon_url: authorIcon || null
                };
            }

            const footerText = document.getElementById('embedFooterInput').value;
            const footerIcon = document.getElementById('embedFooterIconInput').value;
            if (footerText || footerIcon) {
                embed.footer = {
                    text: footerText || null,
                    icon_url: footerIcon || null
                };
            }

            const thumbnail = document.getElementById('embedThumbnailInput').value;
            if (thumbnail) {
                embed.thumbnail = { url: thumbnail };
            }

            const image = document.getElementById('embedImageInput').value;
            if (image) {
                embed.image = { url: image };
            }

            // Remove null values
            Object.keys(embed).forEach(key => {
                if (embed[key] === null) delete embed[key];
            });

            return embed;
        }

        function renderEmbedPreview(embed) {
            if (!embed.title && !embed.description && !embed.fields && !embed.author && !embed.footer) {
                return '<div style="color: #dcddde; font-size: 14px;">Preview will appear here...</div>';
            }

            const colorHex = embed.color ? '#' + embed.color.toString(16).padStart(6, '0') : '#5865F2';
            let html = `<div style="border-left: 4px solid ${colorHex}; padding-left: 12px;">`;

            if (embed.author) {
                html += `<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">`;
                if (embed.author.icon_url) {
                    html += `<img src="${escapeHtml(embed.author.icon_url)}" style="width: 20px; height: 20px; border-radius: 50%;" onerror="this.style.display='none';">`;
                }
                if (embed.author.name) {
                    html += `<span style="color: #fff; font-weight: 600; font-size: 14px;">${escapeHtml(embed.author.name)}</span>`;
                }
                html += `</div>`;
            }

            if (embed.title) {
                const titleStyle = embed.url ? 'color: #00aff4; text-decoration: none;' : 'color: #fff;';
                html += `<div style="${titleStyle} font-weight: 600; font-size: 16px; margin-bottom: 8px;">${escapeHtml(embed.title)}</div>`;
            }

            if (embed.description) {
                html += `<div style="color: #dcddde; font-size: 14px; margin-bottom: 8px; white-space: pre-wrap;">${escapeHtml(embed.description)}</div>`;
            }

            if (embed.fields && embed.fields.length > 0) {
                html += `<div style="margin-top: 12px;">`;
                embed.fields.forEach(field => {
                    html += `<div style="margin-bottom: 8px; ${field.inline ? 'display: inline-block; width: 48%; vertical-align: top; margin-right: 2%;' : ''}">`;
                    html += `<div style="color: #fff; font-weight: 600; font-size: 14px; margin-bottom: 4px;">${escapeHtml(field.name)}</div>`;
                    html += `<div style="color: #dcddde; font-size: 14px; white-space: pre-wrap;">${escapeHtml(field.value)}</div>`;
                    html += `</div>`;
                });
                html += `</div>`;
            }

            if (embed.thumbnail) {
                html += `<div style="margin-top: 12px;"><img src="${escapeHtml(embed.thumbnail.url)}" style="max-width: 80px; max-height: 80px; border-radius: 4px;" onerror="this.style.display='none';"></div>`;
            }

            if (embed.image) {
                html += `<div style="margin-top: 12px;"><img src="${escapeHtml(embed.image.url)}" style="max-width: 100%; border-radius: 4px;" onerror="this.style.display='none';"></div>`;
            }

            if (embed.footer || embed.timestamp) {
                html += `<div style="display: flex; align-items: center; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">`;
                if (embed.footer?.icon_url) {
                    html += `<img src="${escapeHtml(embed.footer.icon_url)}" style="width: 20px; height: 20px; border-radius: 50%;" onerror="this.style.display='none';">`;
                }
                html += `<span style="color: #72767d; font-size: 12px;">`;
                if (embed.footer?.text) {
                    html += escapeHtml(embed.footer.text);
                }
                if (embed.timestamp) {
                    if (embed.footer?.text) html += ' ‚Ä¢ ';
                    html += new Date(embed.timestamp).toLocaleString();
                }
                html += `</span></div>`;
            }

            html += `</div>`;
            return html;
        }

        window.testWebhook = async function() {
            const urlInput = document.getElementById('webhookUrlInput');
            const url = urlInput.value.trim();

            if (!url) {
                alert('Please enter a webhook URL first');
                return;
            }

            const embed = buildEmbedObject();
            await sendWebhook(url, embed, true);
        };

        window.testWebhookById = async function(id) {
            try {
                const snapshot = await database.ref(`webhooks/${id}`).once('value');
                if (snapshot.exists()) {
                    const webhook = snapshot.val();
                    await sendWebhook(webhook.url, webhook.embed, true);
                }
            } catch (error) {
                console.error('Error testing webhook:', error);
                alert('Error testing webhook: ' + error.message);
            }
        };

        async function sendWebhook(url, embed, isTest = false) {
            try {
                const payload = {
                    embeds: embed && Object.keys(embed).length > 0 ? [embed] : []
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    if (isTest) {
                        alert('‚úÖ Test message sent successfully!');
                    }
                    return true;
                } else {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
            } catch (error) {
                console.error('Error sending webhook:', error);
                alert('‚ùå Failed to send webhook: ' + error.message);
                return false;
            }
        }

        window.saveWebhook = async function() {
            const nameInput = document.getElementById('webhookNameInput');
            const urlInput = document.getElementById('webhookUrlInput');
            const errorDiv = document.getElementById('webhookEditorError');

            const name = nameInput.value.trim();
            const url = urlInput.value.trim();

            if (!name) {
                errorDiv.textContent = 'Webhook name is required';
                errorDiv.style.display = 'block';
                return;
            }

            if (!url) {
                errorDiv.textContent = 'Webhook URL is required';
                errorDiv.style.display = 'block';
                return;
            }

            if (!url.includes('discord.com/api/webhooks/')) {
                errorDiv.textContent = 'Invalid Discord webhook URL';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                const embed = buildEmbedObject();
                const webhookData = {
                    name,
                    url,
                    embed: embed && Object.keys(embed).length > 0 ? embed : null,
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                };

                const id = window.currentEditingWebhookId || 'webhook_' + Date.now();
                await database.ref(`webhooks/${id}`).set(webhookData);
                alert('‚úÖ Webhook saved successfully!');
                hideWebhookEditor();
                loadWebhooks();
            } catch (error) {
                console.error('Error saving webhook:', error);
                errorDiv.textContent = 'Failed to save: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        window.deleteWebhook = async function(id) {
            if (!confirm('Are you sure you want to delete this webhook?')) return;
            try {
                await database.ref(`webhooks/${id}`).remove();
                alert('‚úÖ Webhook deleted!');
                loadWebhooks();
            } catch (error) {
                console.error('Error deleting webhook:', error);
                alert('‚ùå Failed to delete: ' + error.message);
            }
        };

        // Update preview when inputs change
        document.addEventListener('DOMContentLoaded', () => {
            const embedInputs = ['embedTitleInput', 'embedDescriptionInput', 'embedUrlInput', 'embedColorInput', 
                                'embedAuthorNameInput', 'embedAuthorIconInput', 'embedFooterInput', 'embedFooterIconInput',
                                'embedThumbnailInput', 'embedImageInput', 'embedTimestampInput'];
            embedInputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', updateEmbedPreview);
                    if (id === 'embedTimestampInput') {
                        input.addEventListener('change', function() {
                            if (this.value === 'custom') {
                                document.getElementById('embedTimestampCustomInput').style.display = 'block';
                            } else {
                                document.getElementById('embedTimestampCustomInput').style.display = 'none';
                            }
                            updateEmbedPreview();
                        });
                    }
                }
            });
        });

        // ============================================
        // KEYAUTH LICENSE KEY MANAGEMENT
        // ============================================
        
        // KeyAuth Configuration
        const KEYAUTH_CONFIG = {
            name: "Recon Spoofer",
            ownerid: "3Fgwv9rfYE",
            version: "1.7",
            url: "https://keyauth.win/api/1.3/",
            sellerKey: "35315ce3dde2445c55a2b0632f23bbfe", // Seller API key for admin operations
            sellerApiUrl: "https://keyauth.win/api/seller/"
        };
        
        // Browser-compatible KeyAuth Client
        class KeyAuthClient {
            constructor(config) {
                this.name = config.name;
                this.ownerid = config.ownerid;
                this.version = config.version;
                this.url = config.url;
                this.sessionid = null;
            }
            
            async init() {
                try {
                    const postData = {
                        type: "init",
                        name: this.name,
                        ownerid: this.ownerid,
                        version: this.version
                    };
                    
                    const response = await this.doRequest(postData);
                    
                    // Handle string responses
                    if (typeof response === 'string') {
                        if (response === "KeyAuth_Invalid") {
                            throw new Error("This application does not exist. Please verify your app name ('Recon Spoofer'), owner ID ('3Fgwv9rfYE'), and version ('1.7') are correct.");
                        }
                        throw new Error(`KeyAuth API returned: ${response}`);
                    }
                    
                    // Handle object responses
                    if (response && typeof response === 'object') {
                        if (response.success === false) {
                            throw new Error(response.message || "Initialization failed");
                        }
                        
                        if (response.message === "invalidver") {
                            throw new Error("Application version mismatch. Please verify the version number.");
                        }
                        
                        if (!response.sessionid) {
                            throw new Error("No session ID received from KeyAuth API. The API may not support browser-based requests.");
                        }
                        
                        this.sessionid = response.sessionid;
                        return true;
                    }
                    
                    throw new Error("Unexpected response format from KeyAuth API");
                } catch (error) {
                    console.error('KeyAuth init error:', error);
                    throw error;
                }
            }
            
            async generateKey(level, expiry, amount, notes) {
                try {
                    // Use seller API for key generation
                    const sellerKey = KEYAUTH_CONFIG.sellerKey;
                    if (!sellerKey) {
                        throw new Error("Seller API key not configured");
                    }
                    
                    // Convert level to number if it's a string
                    let levelNum = 1;
                    if (typeof level === 'string') {
                        // Map common level names to numbers
                        const levelMap = {
                            'Premium': 1,
                            'Pro': 2,
                            'Lifetime': 3,
                            'Basic': 1,
                            'Standard': 2,
                            'Enterprise': 4
                        };
                        levelNum = levelMap[level] || 1;
                    } else {
                        levelNum = level || 1;
                    }
                    
                    // Build seller API URL
                    const params = new URLSearchParams({
                        sellerkey: sellerKey,
                        type: "add",
                        expiry: (expiry || 0).toString(),
                        mask: "******-******-******-******-******-******",
                        level: levelNum.toString(),
                        amount: (amount || 1).toString(),
                        format: "json"
                    });
                    
                    const url = `${KEYAUTH_CONFIG.sellerApiUrl}?${params.toString()}`;
                    
                    const response = await fetch(url, {
                        method: "GET",
                        headers: {
                            "Accept": "application/json"
                        }
                    });
                    
                    // Read response as text first (can only read once)
                    const responseText = await response.text();
                    
                    console.log('KeyAuth Seller API Response:', {
                        status: response.status,
                        statusText: response.statusText,
                        url: url,
                        response: responseText
                    });
                    
                    // Check for error messages in the response text (even if HTTP status is 200)
                    const responseLower = responseText.toLowerCase().trim();
                    const errorKeywords = ['error', 'invalid', 'no object found', 'failed', 'denied', 'unauthorized', 'forbidden'];
                    
                    if (!response.ok || errorKeywords.some(keyword => responseLower.includes(keyword))) {
                        const errorMsg = responseText.trim() || `HTTP ${response.status}: Unknown error`;
                        console.error('KeyAuth Seller API Error:', errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    // Parse response - seller API can return text or JSON
                    let responseData;
                    
                    // Try to parse as JSON first
                    try {
                        responseData = JSON.parse(responseText);
                        // Check if JSON response indicates an error
                        if (responseData.error || responseData.success === false) {
                            throw new Error(responseData.message || responseData.error || 'Key generation failed');
                        }
                    } catch (e) {
                        // If JSON parse fails, check if it's an error message
                        if (e.message && !e.message.includes('JSON')) {
                            throw e; // Re-throw if it's an actual error, not a parse error
                        }
                        // If not JSON, treat as text response (successful key generation)
                        // Text response can be a single key or multiple keys separated by newlines
                        const keys = responseText.trim().split(/\r?\n/).filter(k => k.trim() && !k.toLowerCase().includes('error'));
                        if (keys.length === 0) {
                            throw new Error("Invalid response from KeyAuth API. Please check your seller key and parameters.");
                        }
                        responseData = { keys: keys };
                    }
                    
                    // Handle multiple keys
                    const generatedKeys = responseData.keys || (responseData.key ? [responseData.key] : []);
                    
                    if (generatedKeys.length === 0) {
                        throw new Error("No keys generated. Check your seller API key and parameters.");
                    }
                    
                    // Store keys in Firebase with notes
                    for (const key of generatedKeys) {
                        if (key && key.trim()) {
                            try {
                                const trimmedKey = key.trim();
                                // Escape special characters in Firebase key path
                                const safeKey = trimmedKey.replace(/[.#$\[\]]/g, '_');
                                
                                const keyData = {
                                    key: trimmedKey,
                                    level: level || "Premium",
                                    levelNum: levelNum,
                                    expiry: expiry || 0,
                                    notes: notes || "",
                                    createdAt: Date.now(),
                                    used: false
                                };
                                
                                console.log('Storing key in Firebase:', { safeKey, trimmedKey, keyData });
                                await database.ref(`keyauthKeys/${safeKey}`).set(keyData);
                                console.log('‚úÖ Key stored successfully:', trimmedKey);
                            } catch (e) {
                                console.error('Failed to store key in Firebase:', e, key);
                                throw e; // Re-throw to show error to user
                            }
                        }
                    }
                    
                    return {
                        success: true,
                        keys: generatedKeys,
                        key: generatedKeys[0] // For backward compatibility
                    };
                } catch (error) {
                    console.error('KeyAuth generateKey error:', error);
                    throw error;
                }
            }
            
            async deleteKey(key) {
                try {
                    // Use seller API for key deletion
                    const sellerKey = KEYAUTH_CONFIG.sellerKey;
                    if (!sellerKey) {
                        throw new Error("Seller API key not configured");
                    }
                    
                    // Build seller API URL
                    const params = new URLSearchParams({
                        sellerkey: sellerKey,
                        type: "del",
                        key: key,
                        format: "json"
                    });
                    
                    const url = `${KEYAUTH_CONFIG.sellerApiUrl}?${params.toString()}`;
                    
                    const response = await fetch(url, {
                        method: "GET",
                        headers: {
                            "Accept": "application/json"
                        }
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText || 'Unknown error'}`);
                    }
                    
                    // Parse response - seller API can return text or JSON
                    const responseText = await response.text();
                    let responseData;
                    
                    // Try to parse as JSON first
                    try {
                        responseData = JSON.parse(responseText);
                    } catch (e) {
                        // If not JSON, treat as text response
                        // Check if deletion was successful based on text content
                        const textLower = responseText.toLowerCase();
                        if (textLower.includes('success') || textLower.includes('deleted') || textLower.includes('removed')) {
                            responseData = { success: true, message: responseText };
                        } else if (textLower.includes('error') || textLower.includes('fail')) {
                            responseData = { success: false, message: responseText };
                        } else {
                            // Assume success if no error keywords found
                            responseData = { success: true, message: responseText || "Key deleted successfully" };
                        }
                    }
                    
                    if (responseData.success === false) {
                        throw new Error(responseData.message || "Failed to delete key");
                    }
                    
                    // Remove from Firebase if exists
                    try {
                        await database.ref(`keyauthKeys/${key}`).remove();
                    } catch (e) {
                        console.warn('Failed to remove key from Firebase:', e);
                    }
                    
                    return { success: true, message: "Key deleted successfully" };
                } catch (error) {
                    console.error('KeyAuth deleteKey error:', error);
                    throw error;
                }
            }
            
            async getKeys() {
                try {
                    // Get keys from Firebase (all keys are stored here when generated)
                    const keysFromFirebase = [];
                    try {
                        const keysSnapshot = await database.ref('keyauthKeys').once('value');
                        if (keysSnapshot.exists()) {
                            const keysData = keysSnapshot.val();
                            // Get the actual key value from each entry (not the Firebase key)
                            Object.keys(keysData).forEach(firebaseKey => {
                                const keyEntry = keysData[firebaseKey];
                                if (keyEntry && keyEntry.key) {
                                    keysFromFirebase.push(keyEntry.key);
                                } else {
                                    // Fallback: use Firebase key if key property doesn't exist
                                    keysFromFirebase.push(firebaseKey);
                                }
                            });
                        }
                        console.log('Loaded keys from Firebase:', keysFromFirebase.length);
                    } catch (e) {
                        console.error('Failed to load keys from Firebase:', e);
                    }
                    
                    // Return keys from Firebase (even if empty)
                    // Note: Seller API doesn't support fetchallkeys, so we rely on Firebase storage
                    return keysFromFirebase;
                } catch (error) {
                    console.error('KeyAuth getKeys error:', error);
                    // Return empty array instead of throwing - allows UI to still work
                    return [];
                }
            }
            
            async checkKeyStatus(key) {
                try {
                    // Initialize KeyAuth session if needed
                    if (!this.sessionid) {
                        await this.init();
                    }
                    
                    // Try to use regular KeyAuth API to check key status
                    // We'll try to get user info for the key (if it's been used, it will have user data)
                    const postData = {
                        type: "license",
                        name: this.name,
                        ownerid: this.ownerid,
                        sessionid: this.sessionid,
                        key: key,
                        hwid: "check-status" // Dummy HWID for status check
                    };
                    
                    try {
                        const response = await this.doRequest(postData);
                        
                        // If license check succeeds and has user info, key is used
                        // But we need to verify it actually has user data (username, hwid, etc.)
                        if (response.success === true && response.info) {
                            // Only mark as used if it has actual user activation data
                            // Check for username, hwid, or other user-specific fields
                            const hasUserData = response.info.username || 
                                               response.info.hwid || 
                                               response.info.user ||
                                               (response.info.subscriptions && response.info.subscriptions.length > 0);
                            if (hasUserData) {
                                // Key has been activated and has user info
                                return { used: true, data: response.info };
                            } else {
                                // Key is valid but not yet activated
                                return { used: false };
                            }
                        }
                        
                        // If license check fails with "invalid" or "expired", key might be unused or invalid
                        if (response.success === false) {
                            const message = (response.message || '').toLowerCase();
                            // If it says "already used" or similar, it's been used
                            if (message.includes('already') || message.includes('used') || message.includes('activated')) {
                                return { used: true };
                            }
                            // Otherwise assume unused (could be invalid key)
                            return { used: false };
                        }
                        
                        return { used: false };
                    } catch (apiError) {
                        // If API error, try seller API as fallback
                        console.log('Regular API check failed, trying seller API...', apiError.message);
                        
                        const sellerKey = KEYAUTH_CONFIG.sellerKey;
                        if (sellerKey) {
                            // Try seller API with different endpoint types
                            const endpoints = ['keyinfo', 'info', 'status'];
                            
                            for (const endpointType of endpoints) {
                                try {
                                    const params = new URLSearchParams({
                                        sellerkey: sellerKey,
                                        type: endpointType,
                                        key: key,
                                        format: "json"
                                    });
                                    
                                    const url = `${KEYAUTH_CONFIG.sellerApiUrl}?${params.toString()}`;
                                    const sellerResponse = await fetch(url, {
                                        method: "GET",
                                        headers: { "Accept": "application/json" }
                                    });
                                    
                                    if (sellerResponse.ok) {
                                        const text = await sellerResponse.text();
                                        const lower = text.toLowerCase();
                                        
                                        // Check for indicators that key is used
                                        if (lower.includes('username') || lower.includes('hwid') || 
                                            lower.includes('used') || lower.includes('activated') ||
                                            lower.includes('active') || lower.includes('user')) {
                                            return { used: true };
                                        }
                                        
                                        // Try parsing as JSON
                                        try {
                                            const data = JSON.parse(text);
                                            if (data.username || data.user || data.hwid || data.used || data.activated) {
                                                return { used: true, data: data };
                                            }
                                        } catch (e) {
                                            // Not JSON, continue
                                        }
                                    }
                                } catch (e) {
                                    // Try next endpoint
                                    continue;
                                }
                            }
                        }
                        
                        // If all methods fail, return unknown status
                        return { used: false, error: 'Unable to determine status' };
                    }
                } catch (error) {
                    console.warn('Error checking key status:', error);
                    return { used: false, error: error.message };
                }
            }
            
            async doRequest(data) {
                try {
                    const formData = new URLSearchParams();
                    for (const key in data) {
                        formData.append(key, data[key]);
                    }
                    
                    const response = await fetch(this.url, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        },
                        body: formData.toString()
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText || 'Unknown error'}`);
                    }
                    
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        const responseData = await response.json();
                        
                        // Handle string responses (like "KeyAuth_Invalid")
                        if (typeof responseData === 'string') {
                            if (responseData === "KeyAuth_Invalid") {
                                throw new Error("This application does not exist. Please verify your app name and owner ID.");
                            }
                            return { success: false, message: responseData };
                        }
                        
                        return responseData;
                    } else {
                        // Handle non-JSON responses
                        const text = await response.text();
                        if (text === "KeyAuth_Invalid") {
                            throw new Error("This application does not exist. Please verify your app name and owner ID.");
                        }
                        throw new Error(`Unexpected response format: ${text.substring(0, 100)}`);
                    }
                } catch (error) {
                    console.error('KeyAuth request error:', error);
                    // Provide more helpful error messages
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('Network error: KeyAuth API may not be accessible from browser. Consider using a server-side proxy.');
                    }
                    if (error.message.includes('CORS')) {
                        throw new Error('CORS error: KeyAuth API does not allow browser requests. You may need to use a server-side proxy.');
                    }
                    throw error;
                }
            }
        }
        
        // Initialize KeyAuth client
        let keyAuthClient = null;
        let keyAuthInitialized = false;
        let keyAuthInitError = null;
        
        async function initKeyAuth() {
            try {
                keyAuthClient = new KeyAuthClient(KEYAUTH_CONFIG);
                await keyAuthClient.init();
                keyAuthInitialized = true;
                keyAuthInitError = null;
                console.log('‚úÖ KeyAuth initialized successfully');
            } catch (error) {
                keyAuthInitialized = false;
                keyAuthInitError = error;
                console.error('‚ùå KeyAuth initialization failed:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    config: KEYAUTH_CONFIG
                });
                // Don't show alert on page load - only show when user tries to use it
                // The error will be shown when user tries to generate/load keys
            }
        }
        
        // Load keys
        async function loadKeys(autoSync = false) {
            const content = document.getElementById('keysContent');
            if (!content) return;
            
            const searchQuery = document.getElementById('keySearchInput')?.value.toLowerCase() || '';
            const statusFilter = document.getElementById('keyFilterStatus')?.value || 'all';
            
            try {
                content.innerHTML = '<div class="loading">Loading keys...</div>';
                
                // Check if user is a granted user (not full admin)
                const access = await getUserAccessLevel();
                const isGrantedUser = access && access.level === 'granted';
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                
                // Determine storage path
                const storagePath = isGrantedUser ? `${LICENSE_KEYS_PATH}/${userProfileId}` : 'keyauthKeys';
                
                // Full admin - load KeyAuth keys from API
                // Granted users - load their personal keys from Firebase
                let keys = [];
                
                if (isGrantedUser) {
                    // Load from user's personal storage
                    const keysSnapshot = await window.database.ref(storagePath).once('value');
                    if (keysSnapshot.exists()) {
                        const keysData = keysSnapshot.val();
                        keys = Object.values(keysData).map(k => k.key || k);
                    }
                } else {
                    // Full admin - load from KeyAuth API
                    if (!keyAuthClient) {
                        keyAuthClient = new KeyAuthClient(KEYAUTH_CONFIG);
                    }
                    keys = await keyAuthClient.getKeys();
                }
                
                // Auto-sync key status if enabled (check first 10 keys to avoid long delays)
                // IMPORTANT: Only update if status changes from unused to used, never the reverse
                if (autoSync && keys.length > 0 && keys.length <= 50) {
                    try {
                        console.log('Auto-syncing key status with KeyAuth API...');
                        let updated = 0;
                        const keysToCheck = keys.slice(0, 10); // Check first 10 keys to avoid delays
                        
                        for (const key of keysToCheck) {
                            try {
                                console.log(`Checking key status: ${key.substring(0, 10)}...`);
                                
                                // First, check current status in Firebase
                                const safeKey = key.replace(/[.#$\[\]]/g, '_');
                                const currentSnapshot = await window.database.ref(`${storagePath}/${safeKey}`).once('value');
                                const currentData = currentSnapshot.exists() ? currentSnapshot.val() : null;
                                
                                // Skip checking if key was just created (within last 5 seconds) to avoid false positives
                                if (currentData && currentData.createdAt) {
                                    const timeSinceCreation = Date.now() - currentData.createdAt;
                                    if (timeSinceCreation < 5000) {
                                        console.log(`Skipping check for recently created key: ${key.substring(0, 10)}...`);
                                        continue;
                                    }
                                }
                                
                                // Only check status if key is currently marked as unused
                                // If it's already marked as used, don't re-check (prevents false negatives)
                                if (currentData && currentData.used === true) {
                                    console.log(`Key already marked as used, skipping: ${key.substring(0, 10)}...`);
                                    continue;
                                }
                                
                                const status = await keyAuthClient.checkKeyStatus(key);
                                console.log(`Key status result:`, status);
                                
                                if (status.used !== undefined && !status.error) {
                                    // Only update if changing from unused to used
                                    // Never change from used to unused (that would be a false negative)
                                    if (status.used === true && (!currentData || currentData.used !== true)) {
                                        await window.database.ref(`${storagePath}/${safeKey}/used`).set(true);
                                        updated++;
                                        console.log(`‚úÖ Updated key as used: ${key.substring(0, 10)}...`);
                                    } else if (status.used === false) {
                                        // Key is confirmed unused, but only update if it wasn't already set
                                        if (!currentData || currentData.used === undefined) {
                                            await window.database.ref(`${storagePath}/${safeKey}/used`).set(false);
                                        }
                                    }
                                } else if (status.error) {
                                    console.warn(`Could not check key ${key.substring(0, 10)}...: ${status.error}`);
                                }
                                // Small delay to avoid rate limiting
                                await new Promise(resolve => setTimeout(resolve, 200));
                            } catch (e) {
                                console.warn(`Error checking key ${key.substring(0, 10)}...:`, e.message);
                                // Continue with next key
                            }
                        }
                        
                        if (updated > 0) {
                            console.log(`Auto-sync updated ${updated} key(s)`);
                        }
                    } catch (e) {
                        console.warn('Auto-sync error (non-critical):', e);
                    }
                }
                
                if (!keys || keys.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No keys found. Generate your first key to get started!</div></div>';
                    return;
                }
                
                // Get additional data from Firebase
                const keysWithData = await Promise.all(keys.map(async (key) => {
                    try {
                        // Use safe key format for Firebase lookup (escape special characters)
                        const safeKey = key.replace(/[.#$\[\]]/g, '_');
                        const keySnapshot = await window.database.ref(`${storagePath}/${safeKey}`).once('value');
                        const keyData = keySnapshot.exists() ? keySnapshot.val() : null;
                        return {
                            key: key,
                            level: keyData?.level || 'Unknown',
                            expiry: keyData?.expiry || 0,
                            notes: keyData?.notes || '',
                            createdAt: keyData?.createdAt || Date.now(),
                            used: keyData?.used || false,
                            storagePath: storagePath,
                            safeKey: safeKey
                        };
                    } catch (e) {
                        return {
                            key: key,
                            level: 'Unknown',
                            expiry: 0,
                            notes: '',
                            createdAt: Date.now(),
                            used: false,
                            storagePath: storagePath,
                            safeKey: key.replace(/[.#$\[\]]/g, '_')
                        };
                    }
                }));
                
                // Filter by search
                let filteredKeys = keysWithData;
                if (searchQuery) {
                    filteredKeys = filteredKeys.filter(k => 
                        k.key.toLowerCase().includes(searchQuery) ||
                        k.level.toLowerCase().includes(searchQuery) ||
                        k.notes.toLowerCase().includes(searchQuery)
                    );
                }
                
                // Filter by status
                if (statusFilter !== 'all') {
                    const now = Date.now();
                    filteredKeys = filteredKeys.filter(k => {
                        if (statusFilter === 'used') return k.used;
                        if (statusFilter === 'unused') return !k.used;
                        if (statusFilter === 'expired') {
                            if (k.expiry === 0) return false; // Lifetime key
                            const expiryTime = k.createdAt + (k.expiry * 24 * 60 * 60 * 1000);
                            return now > expiryTime;
                        }
                        return true;
                    });
                }
                
                if (filteredKeys.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No keys found</div></div>';
                    return;
                }
                
                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>License Key</th>
                                <th>Level</th>
                                <th>Status</th>
                                <th>Expires</th>
                                <th>Notes</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                filteredKeys.forEach(keyData => {
                    const now = Date.now();
                    const isExpired = keyData.expiry > 0 && (now > (keyData.createdAt + (keyData.expiry * 24 * 60 * 60 * 1000)));
                    const status = isExpired ? 'Expired' : (keyData.used ? 'Used' : 'Unused');
                    const statusClass = isExpired ? 'status-inactive' : (keyData.used ? 'status-inactive' : 'status-active');
                    
                    const expiryText = keyData.expiry === 0 ? 'Lifetime' : 
                        new Date(keyData.createdAt + (keyData.expiry * 24 * 60 * 60 * 1000)).toLocaleDateString();
                    
                    html += `
                        <tr>
                            <td style="font-family: monospace; font-size: 12px; word-break: break-all;">${escapeHtml(keyData.key)}</td>
                            <td>${escapeHtml(keyData.level)}</td>
                            <td><span class="status-badge ${statusClass}">${status}</span></td>
                            <td>${expiryText}</td>
                            <td style="max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(keyData.notes)}">${escapeHtml(keyData.notes || '-')}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="copyKey('${escapeHtml(keyData.key)}')" title="Copy Key">üìã</button>
                                    ${!keyData.used ? `<button class="btn-action" onclick="markKeyAsUsed('${escapeHtml(keyData.key)}', '${escapeHtml(keyData.storagePath)}', '${escapeHtml(keyData.safeKey)}')" style="background: rgba(34, 197, 94, 0.2); border-color: rgba(34, 197, 94, 0.3); color: #22c55e;" title="Mark as Used">‚úì</button>` : ''}
                                    <button class="btn-action btn-delete" onclick="deleteKey('${escapeHtml(keyData.key)}', '${escapeHtml(keyData.storagePath)}', '${escapeHtml(keyData.safeKey)}')" style="background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.3); color: #ef4444;" title="Delete Key">üóëÔ∏è</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading keys:', error);
                const errorMsg = error.message || 'Unknown error';
                content.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-text">Error loading keys: ${escapeHtml(errorMsg)}</div>
                        <div style="margin-top: 16px; color: #888; font-size: 13px;">
                            <p>KeyAuth API may require server-side authentication or may not support browser-based requests.</p>
                            <p style="margin-top: 8px;">Please verify your KeyAuth credentials and ensure the API supports browser access.</p>
                        </div>
                        <button class="admin-btn" onclick="loadKeys()" style="margin-top: 16px;">Retry</button>
                    </div>
                `;
            }
        }
        
        // Show generate key modal
        function showGenerateKeyModal() {
            const modal = document.getElementById('generateKeyModal');
            if (modal) {
                modal.classList.add('active');
                // Reset form
                document.getElementById('keyLevelInput').value = 'Premium';
                document.getElementById('keyExpiryInput').value = '';
                document.getElementById('keyCountInput').value = '1';
                document.getElementById('keyNotesInput').value = '';
                document.getElementById('keyGenerationError').style.display = 'none';
            }
        }
        
        // Close generate key modal
        function closeGenerateKeyModal() {
            const modal = document.getElementById('generateKeyModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        // Generate key
        async function generateKey() {
            const errorDiv = document.getElementById('keyGenerationError');
            const levelInput = document.getElementById('keyLevelInput');
            const expiryInput = document.getElementById('keyExpiryInput');
            const countInput = document.getElementById('keyCountInput');
            const notesInput = document.getElementById('keyNotesInput');
            
            if (!levelInput || !expiryInput || !countInput) return;
            
            const level = levelInput.value.trim();
            const expiry = expiryInput.value ? parseInt(expiryInput.value) : 0;
            const count = parseInt(countInput.value) || 1;
            const notes = notesInput.value.trim();
            
            if (!level) {
                errorDiv.textContent = 'Level is required';
                errorDiv.style.display = 'block';
                return;
            }
            
            if (count < 1 || count > 100) {
                errorDiv.textContent = 'Count must be between 1 and 100';
                errorDiv.style.display = 'block';
                return;
            }
            
            try {
                errorDiv.style.display = 'none';
                
                if (!keyAuthClient || !keyAuthInitialized) {
                    await initKeyAuth();
                }
                
                if (!keyAuthInitialized) {
                    errorDiv.textContent = 'KeyAuth not initialized: ' + (keyAuthInitError?.message || 'Unknown error. Please check your credentials.');
                    errorDiv.style.display = 'block';
                    return;
                }
                
                const generatedKeys = [];
                const errors = [];
                
                // Generate keys one by one
                for (let i = 0; i < count; i++) {
                    try {
                        const response = await keyAuthClient.generateKey(level, expiry, 1, notes);
                        // Handle both single key and multiple keys response
                        if (response.keys && Array.isArray(response.keys)) {
                            generatedKeys.push(...response.keys);
                        } else if (response.key) {
                            generatedKeys.push(response.key);
                        } else {
                            throw new Error('No key returned from API');
                        }
                    } catch (error) {
                        errors.push(`Key ${i + 1}: ${error.message}`);
                    }
                }
                
                if (generatedKeys.length > 0) {
                    // Determine storage path based on user type
                    const access = await getUserAccessLevel();
                    const isGrantedUser = access && access.level === 'granted';
                    const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                    const storagePath = isGrantedUser ? `${LICENSE_KEYS_PATH}/${userProfileId}` : 'keyauthKeys';
                    
                    // Save generated keys to Firebase
                    for (const key of generatedKeys) {
                        const safeKey = key.replace(/[.#$\[\]]/g, '_');
                        const keyData = {
                            key: key,
                            level: level,
                            expiry: expiry,
                            notes: notes || '',
                            createdAt: Date.now(),
                            used: false
                        };
                        await window.database.ref(`${storagePath}/${safeKey}`).set(keyData);
                    }
                    
                    let message = `‚úÖ Successfully generated ${generatedKeys.length} key(s)!\n\nKeys:\n${generatedKeys.join('\n')}`;
                    if (errors.length > 0) {
                        message += `\n\nErrors:\n${errors.join('\n')}`;
                    }
                    alert(message);
                    closeGenerateKeyModal();
                    await loadKeys();
                } else {
                    errorDiv.textContent = errors.length > 0 ? errors.join('; ') : 'Failed to generate keys';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Error generating key:', error);
                errorDiv.textContent = 'Error: ' + (error.message || 'Unknown error');
                errorDiv.style.display = 'block';
            }
        }
        
        // Mark key as used
        async function markKeyAsUsed(key, storagePath = null, safeKey = null) {
            if (!confirm(`Mark key "${key}" as used?`)) {
                return;
            }
            
            try {
                // Determine storage path if not provided
                if (!storagePath) {
                    const access = await getUserAccessLevel();
                    const isGrantedUser = access && access.level === 'granted';
                    const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                    storagePath = isGrantedUser ? `${LICENSE_KEYS_PATH}/${userProfileId}` : 'keyauthKeys';
                }
                
                if (!safeKey) {
                    safeKey = key.replace(/[.#$\[\]]/g, '_');
                }
                
                await window.database.ref(`${storagePath}/${safeKey}/used`).set(true);
                console.log('‚úÖ Key marked as used:', key);
                await loadKeys();
            } catch (error) {
                console.error('Error marking key as used:', error);
                alert('Error: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Sync key status from KeyAuth API
        async function syncKeyStatus() {
            if (!confirm('This will check all keys with KeyAuth API to update their status. This may take a while. Continue?')) {
                return;
            }
            
            try {
                const content = document.getElementById('keysContent');
                if (content) {
                    content.innerHTML = '<div class="loading">Syncing key status with KeyAuth API...</div>';
                }
                
                if (!keyAuthClient) {
                    keyAuthClient = new KeyAuthClient(KEYAUTH_CONFIG);
                }
                
                // Determine storage path based on user type
                const access = await getUserAccessLevel();
                const isGrantedUser = access && access.level === 'granted';
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                const storagePath = isGrantedUser ? `${LICENSE_KEYS_PATH}/${userProfileId}` : 'keyauthKeys';
                
                // Initialize KeyAuth if needed
                if (!keyAuthInitialized) {
                    console.log('Initializing KeyAuth for sync...');
                    await initKeyAuth();
                    if (!keyAuthInitialized) {
                        throw new Error('KeyAuth initialization failed: ' + (keyAuthInitError?.message || 'Unknown error'));
                    }
                }
                
                // Get keys - from API for full admin, from Firebase for granted users
                let keys = [];
                if (isGrantedUser) {
                    const keysSnapshot = await window.database.ref(storagePath).once('value');
                    if (keysSnapshot.exists()) {
                        const keysData = keysSnapshot.val();
                        keys = Object.values(keysData).map(k => k.key || k);
                    }
                } else {
                    keys = await keyAuthClient.getKeys();
                }
                
                if (!keys || keys.length === 0) {
                    alert('No keys found to sync.');
                    await loadKeys();
                    return;
                }
                
                let updated = 0;
                let errors = 0;
                let checked = 0;
                
                console.log(`Starting sync for ${keys.length} keys...`);
                
                // Check each key's status with KeyAuth API
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    try {
                        if (content) {
                            content.innerHTML = `<div class="loading">Checking key ${i + 1} of ${keys.length}...<br><small>${key.substring(0, 20)}...</small></div>`;
                        }
                        
                        console.log(`[${i + 1}/${keys.length}] Checking: ${key.substring(0, 15)}...`);
                        const status = await keyAuthClient.checkKeyStatus(key);
                        checked++;
                        
                        console.log(`Status result:`, status);
                        
                        if (status.used !== undefined && !status.error) {
                            const safeKey = key.replace(/[.#$\[\]]/g, '_');
                            const currentSnapshot = await window.database.ref(`${storagePath}/${safeKey}`).once('value');
                            const currentData = currentSnapshot.exists() ? currentSnapshot.val() : null;
                            
                            // Only update if status changed
                            if (!currentData || currentData.used !== status.used) {
                                await window.database.ref(`${storagePath}/${safeKey}/used`).set(status.used);
                                if (status.used) {
                                    updated++;
                                    console.log(`‚úÖ Updated: ${key.substring(0, 15)}... marked as USED`);
                                } else {
                                    console.log(`‚úÖ Updated: ${key.substring(0, 15)}... marked as UNUSED`);
                                }
                            } else {
                                console.log(`‚è≠Ô∏è  No change: ${key.substring(0, 15)}... (already ${status.used ? 'used' : 'unused'})`);
                            }
                        } else if (status.error) {
                            console.warn(`‚ö†Ô∏è  Error checking ${key.substring(0, 15)}...: ${status.error}`);
                            errors++;
                        }
                        
                        // Delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`‚ùå Error checking key ${key.substring(0, 15)}...:`, error);
                        errors++;
                    }
                }
                
                console.log(`Sync completed. Checked: ${checked}, Updated: ${updated}, Errors: ${errors}`);
                await loadKeys();
                
                alert(`‚úÖ Sync completed!\n\nChecked: ${checked} key(s)\nUpdated: ${updated} key(s)\nErrors: ${errors}`);
            } catch (error) {
                console.error('Error syncing keys:', error);
                alert('Error syncing keys: ' + (error.message || 'Unknown error') + '\n\nCheck console for details.');
                await loadKeys(); // Reload anyway
            }
        }
        
        // Delete key
        async function deleteKey(key, storagePath = null, safeKey = null) {
            if (!confirm(`Are you sure you want to delete this key?\n\n${key}\n\nThis action cannot be undone.`)) {
                return;
            }
            
            try {
                // Determine storage path if not provided
                if (!storagePath) {
                    const access = await getUserAccessLevel();
                    const isGrantedUser = access && access.level === 'granted';
                    const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                    storagePath = isGrantedUser ? `${LICENSE_KEYS_PATH}/${userProfileId}` : 'keyauthKeys';
                }
                
                if (!safeKey) {
                    safeKey = key.replace(/[.#$\[\]]/g, '_');
                }
                
                // Delete from KeyAuth API (if full admin)
                const access = await getUserAccessLevel();
                if (!access || access.level !== 'granted') {
                    if (!keyAuthClient || !keyAuthInitialized) {
                        await initKeyAuth();
                    }
                    
                    if (keyAuthInitialized) {
                        try {
                            await keyAuthClient.deleteKey(key);
                        } catch (apiError) {
                            console.warn('KeyAuth API delete failed, continuing with Firebase delete:', apiError);
                        }
                    }
                }
                
                // Delete from Firebase
                await window.database.ref(`${storagePath}/${safeKey}`).remove();
                alert('‚úÖ Key deleted successfully');
                await loadKeys();
            } catch (error) {
                console.error('Error deleting key:', error);
                alert('Failed to delete key: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Copy key to clipboard
        function copyKey(key) {
            navigator.clipboard.writeText(key).then(() => {
                alert('‚úÖ Key copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = key;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('‚úÖ Key copied to clipboard!');
            });
        }
        
        // Export keys to CSV
        async function exportKeys() {
            try {
                if (!keyAuthClient || !keyAuthInitialized) {
                    await initKeyAuth();
                }
                
                if (!keyAuthInitialized) {
                    alert('KeyAuth not initialized: ' + (keyAuthInitError?.message || 'Unknown error. Please check your credentials.'));
                    return;
                }
                
                const keys = await keyAuthClient.getKeys();
                const keysWithData = await Promise.all(keys.map(async (key) => {
                    try {
                        const keySnapshot = await database.ref(`keyauthKeys/${key}`).once('value');
                        const keyData = keySnapshot.exists() ? keySnapshot.val() : null;
                        return {
                            key: key,
                            level: keyData?.level || 'Unknown',
                            expiry: keyData?.expiry || 0,
                            notes: keyData?.notes || '',
                            createdAt: keyData?.createdAt || Date.now(),
                            used: keyData?.used || false
                        };
                    } catch (e) {
                        return {
                            key: key,
                            level: 'Unknown',
                            expiry: 0,
                            notes: '',
                            createdAt: Date.now(),
                            used: false
                        };
                    }
                }));
                
                let csv = 'License Key,Level,Status,Expires,Notes,Created\n';
                keysWithData.forEach(k => {
                    const now = Date.now();
                    const isExpired = k.expiry > 0 && (now > (k.createdAt + (k.expiry * 24 * 60 * 60 * 1000)));
                    const status = isExpired ? 'Expired' : (k.used ? 'Used' : 'Unused');
                    const expiryText = k.expiry === 0 ? 'Lifetime' : 
                        new Date(k.createdAt + (k.expiry * 24 * 60 * 60 * 1000)).toLocaleDateString();
                    const createdText = new Date(k.createdAt).toLocaleDateString();
                    
                    csv += `"${k.key}","${k.level}","${status}","${expiryText}","${k.notes.replace(/"/g, '""')}","${createdText}"\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `keys-export-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('‚úÖ Keys exported successfully!');
            } catch (error) {
                console.error('Error exporting keys:', error);
                alert('Failed to export keys: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Initialize KeyAuth on page load (non-blocking, silent failure)
        // KeyAuth will be initialized when user tries to use key management features
        // This prevents blocking the admin panel if KeyAuth API is unavailable
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Try to initialize silently in background
                initKeyAuth().catch(() => {
                    // Silently fail - will show error when user tries to use features
                });
            });
        } else {
            // Try to initialize silently in background
            initKeyAuth().catch(() => {
                // Silently fail - will show error when user tries to use features
            });
        }

        // ============================================
        // TICKETS MANAGEMENT FUNCTIONS
        // ============================================
        async function loadTickets() {
            const content = document.getElementById('ticketsContent');
            const statusFilter = document.getElementById('ticketFilterStatus')?.value || 'all';
            const searchQuery = document.getElementById('ticketSearchInput')?.value.toLowerCase() || '';

            try {
                const snapshot = await database.ref('tickets').once('value');
                if (!snapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No tickets found</div></div>';
                    return;
                }

                const tickets = snapshot.val();
                let entries = Object.entries(tickets)
                    .map(([id, ticket]) => ({ id, ...ticket }))
                    .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

                // Filter by status
                if (statusFilter !== 'all') {
                    entries = entries.filter(ticket => ticket.status === statusFilter);
                }

                // Filter by search
                if (searchQuery) {
                    entries = entries.filter(ticket => 
                        ticket.id.toLowerCase().includes(searchQuery) ||
                        ticket.subject.toLowerCase().includes(searchQuery) ||
                        (ticket.userIp && ticket.userIp.toLowerCase().includes(searchQuery))
                    );
                }

                if (entries.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No tickets found</div></div>';
                    return;
                }

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Ticket ID</th>
                                <th>Subject</th>
                                <th>Status</th>
                                <th>User IP</th>
                                <th>Created</th>
                                <th>Updated</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                entries.forEach(ticket => {
                    const createdDate = new Date(ticket.createdAt);
                    const updatedDate = new Date(ticket.updatedAt);
                    html += `
                        <tr>
                            <td style="font-family: monospace; font-size: 12px;">${escapeHtml(ticket.id)}</td>
                            <td>${escapeHtml(ticket.subject || 'No subject')}</td>
                            <td><span class="status-badge ${ticket.status === 'open' ? 'status-active' : 'status-inactive'}">${ticket.status || 'open'}</span></td>
                            <td style="font-family: monospace; font-size: 12px;">${escapeHtml(ticket.userIp || 'Unknown')}</td>
                            <td>${createdDate.toLocaleString()}</td>
                            <td>${updatedDate.toLocaleString()}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="viewAdminTicket('${ticket.id}')">View</button>
                                    <button class="btn-action btn-delete" onclick="deleteAdminTicket('${ticket.id}')" style="background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.3); color: #ef4444;">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading tickets:', error);
                content.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error loading tickets</div></div>';
            }
        }

        // ============================================
        // NEW TICKET SYSTEM (ADMIN) - GUARANTEED 0 ERRORS
        // ============================================
        window.TicketSystemAdmin = {
            currentTicketId: null,
            messageListener: null,
            
            // Get element safely
            getElement: function(id) {
                const el = document.getElementById(id);
                if (!el) {
                    console.error(`Element not found: ${id}`);
                }
                return el;
            },
            
            // View ticket
            view: async function(ticketId) {
                if (!ticketId || typeof ticketId !== 'string') {
                    alert('Invalid ticket ID');
                    return;
                }
                
                const modal = this.getElement('adminTicketModal');
                if (!modal) {
                    alert('Ticket modal not found. Please refresh the page.');
                    return;
                }
                
                if (!window.firebaseInitialized || !window.database) {
                    alert('Firebase not initialized. Please refresh the page.');
                    return;
                }
                
                try {
                    // Show modal and loading state
                    modal.classList.add('active');
                    const messagesContainer = this.getElement('adminTicketMessages');
                    if (messagesContainer) {
                        messagesContainer.innerHTML = '<div style="color: #888; text-align: center; padding: 40px;">Loading ticket...</div>';
                    }
                    
                    // Load ticket
                    const ticketSnapshot = await window.database.ref(`tickets/${ticketId}`).once('value');
                    if (!ticketSnapshot.exists()) {
                        alert('Ticket not found');
                        this.closeModal();
                        return;
                    }
                    
                    const ticket = ticketSnapshot.val();
                    if (!ticket) {
                        alert('Invalid ticket data');
                        this.closeModal();
                        return;
                    }
                    
                    // Update UI elements safely
                    const titleEl = this.getElement('adminTicketTitle');
                    const idEl = this.getElement('adminTicketId');
                    const closeBtn = this.getElement('closeTicketBtn');
                    
                    if (titleEl) titleEl.textContent = ticket.subject || 'No Subject';
                    if (idEl) idEl.textContent = ticket.id || ticketId;
                    if (closeBtn) {
                        closeBtn.textContent = ticket.status === 'closed' ? 'Reopen Ticket' : 'Close Ticket';
                    }
                    
                    // Load messages
                    await this.loadMessages(ticketId);
                    
                    // Set up real-time listener
                    this.setupListener(ticketId);
                    
                    this.currentTicketId = ticketId;
                } catch (error) {
                    console.error('Error loading ticket:', error);
                    alert('Error loading ticket: ' + (error.message || 'Unknown error'));
                    this.closeModal();
                }
            },
            
            // Load messages
            loadMessages: async function(ticketId) {
                const container = this.getElement('adminTicketMessages');
                if (!container) return;
                
                try {
                    // Get ticket to access userId
                    const ticketSnapshot = await window.database.ref(`tickets/${ticketId}`).once('value');
                    const ticket = ticketSnapshot.exists() ? ticketSnapshot.val() : null;
                    const userId = ticket ? ticket.userId : null;
                    
                    const snapshot = await window.database.ref(`ticketMessages/${ticketId}`).once('value');
                    const messages = snapshot.exists() ? snapshot.val() : {};
                    const messagesArray = Object.entries(messages)
                        .map(([ts, msg]) => {
                            try {
                                return {
                                    timestamp: parseInt(ts) || Date.now(),
                                    message: (msg && msg.message) ? String(msg.message) : '',
                                    sender: (msg && msg.sender) ? String(msg.sender) : 'user',
                                    images: Array.isArray(msg.images) ? msg.images : [],
                                    voice: msg.voice || null
                                };
                            } catch (e) {
                                return null;
                            }
                        })
                        .filter(m => m !== null && (m.message || (Array.isArray(m.images) && m.images.length > 0) || (m.voice && m.voice.data)))
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    await this.renderMessages(messagesArray, container, userId);
                } catch (error) {
                    console.error('Error loading messages:', error);
                    container.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error loading messages</div>';
                }
            },
            
            // Get user profile for ticket messages
            getUserProfileForTicket: async function(userId) {
                if (!userId || !window.database) return null;
                
                try {
                    const profileSnapshot = await window.database.ref(`userProfiles/${userId}`).once('value');
                    if (profileSnapshot.exists()) {
                        return profileSnapshot.val();
                    }
                } catch (error) {
                    console.error('Error loading user profile:', error);
                }
                return null;
            },
            
            // Render messages
            renderMessages: async function(messages, container, userId) {
                if (!container) return;
                
                if (!Array.isArray(messages) || messages.length === 0) {
                    container.innerHTML = '<div style="color: #888; text-align: center; padding: 40px;">No messages yet</div>';
                    return;
                }
                
                try {
                    // Load user profile if userId is provided
                    const userProfile = userId ? await this.getUserProfileForTicket(userId) : null;
                    
                    const html = await Promise.all(messages.map(async (msg) => {
                        try {
                            const date = new Date(msg.timestamp || Date.now());
                            const isUser = msg.sender === 'user';
                            const messageText = escapeHtml(String(msg.message || ''));
                            
                            const images = Array.isArray(msg.images) ? msg.images : [];
                            const voice = msg.voice || null;
                            
                            // Get profile info for user messages
                            let profileInfo = '';
                            if (isUser && userProfile) {
                                const avatarSrc = userProfile.avatar || `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2224%22 height=%2224%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22 fill=%22%233a3a3a%22/%3E%3Ctext x=%2212%22 y=%2216%22 font-size=%2210%22 fill=%22%23fff%22 text-anchor=%22middle%22%3E${encodeURIComponent((userProfile.username || '?').charAt(0).toUpperCase())}%3C/text%3E%3C/svg%3E`;
                                profileInfo = `
                                    <div class="ticket-message-user-info">
                                        <img class="ticket-message-avatar" src="${escapeHtml(avatarSrc)}" alt="${escapeHtml(userProfile.username || 'User')}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2224%22 height=%2224%22%3E%3Ccircle cx=%2212%22 cy=%2212%22 r=%2212%22 fill=%22%233a3a3a%22/%3E%3C/svg%3E'">
                                        <span class="ticket-message-username">${escapeHtml(userProfile.username || 'User')}</span>
                                    </div>
                                `;
                            } else if (isUser) {
                                profileInfo = '<span class="ticket-message-username">User</span>';
                            } else {
                                profileInfo = '<span class="ticket-message-username">Admin</span>';
                            }
                            
                            let imagesHtml = '';
                            if (images.length > 0) {
                                imagesHtml = images.map(img => `
                                    <div class="ticket-message-image">
                                        <img src="${escapeHtml(img.data)}" alt="${escapeHtml(img.name || 'Image')}" onclick="window.openImageModal('${escapeHtml(img.data)}')">
                                    </div>
                                `).join('');
                            }
                            
                            let voiceHtml = '';
                            if (voice && voice.data) {
                                const voiceId = `voice_${msg.timestamp}_${Math.random().toString(36).substr(2, 9)}`;
                                voiceHtml = `
                                    <div class="ticket-voice-message">
                                        <div class="ticket-voice-player">
                                            <button class="ticket-voice-play-btn" onclick="TicketSystemAdmin.playVoice('${voiceId}', '${escapeHtml(voice.data)}')" id="${voiceId}_btn">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                                </svg>
                                            </button>
                                            <span class="ticket-voice-duration" id="${voiceId}_duration">Voice Message</span>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            return `
                                <div class="ticket-message ${isUser ? 'user' : 'admin'}">
                                    <div class="ticket-message-header">
                                        ${profileInfo}
                                        <span style="color: #666;">‚Ä¢</span>
                                        <span>${date.toLocaleString()}</span>
                                    </div>
                                    ${messageText ? `<div class="ticket-message-text">${messageText}</div>` : ''}
                                    ${imagesHtml}
                                    ${voiceHtml}
                                </div>
                            `;
                        } catch (e) {
                            return '';
                        }
                    }));
                    
                    container.innerHTML = html.filter(h => h).join('') || '<div style="color: #888; text-align: center; padding: 40px;">No valid messages</div>';
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 50);
                } catch (error) {
                    console.error('Error rendering messages:', error);
                    container.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error displaying messages</div>';
                }
            },
            
            // Setup real-time listener
            setupListener: function(ticketId) {
                // Clean up previous listener
                if (this.messageListener && this.currentTicketId) {
                    try {
                        window.database.ref(`ticketMessages/${this.currentTicketId}`).off('value', this.messageListener);
                    } catch (e) {
                        console.warn('Error removing listener:', e);
                    }
                }
                
                this.messageListener = async (snapshot) => {
                    const container = this.getElement('adminTicketMessages');
                    if (!container) return;
                    
                    try {
                        // Get ticket to access userId
                        const ticketSnapshot = await window.database.ref(`tickets/${this.currentTicketId}`).once('value');
                        const ticket = ticketSnapshot.exists() ? ticketSnapshot.val() : null;
                        const userId = ticket ? ticket.userId : null;
                        
                        const msgs = snapshot.exists() ? snapshot.val() : {};
                        const msgsArray = Object.entries(msgs)
                            .map(([ts, msg]) => {
                                try {
                                    return {
                                        timestamp: parseInt(ts) || Date.now(),
                                        message: (msg && msg.message) ? String(msg.message) : '',
                                        sender: (msg && msg.sender) ? String(msg.sender) : 'user',
                                        images: Array.isArray(msg.images) ? msg.images : [],
                                        voice: msg.voice || null
                                    };
                                } catch (e) {
                                    return null;
                                }
                            })
                            .filter(m => m !== null && (m.message || (Array.isArray(m.images) && m.images.length > 0) || (m.voice && m.voice.data)))
                            .sort((a, b) => a.timestamp - b.timestamp);
                        
                        await this.renderMessages(msgsArray, container, userId);
                    } catch (error) {
                        console.error('Error in listener:', error);
                    }
                };
                
                try {
                    window.database.ref(`ticketMessages/${ticketId}`).on('value', this.messageListener);
                } catch (error) {
                    console.error('Error setting up listener:', error);
                }
            },
            
            // Image handling
            attachedImages: [],
            
            handleImageUpload: function(files) {
                const maxSize = 5 * 1024 * 1024; // 5MB
                const maxImages = 5;
                
                if (this.attachedImages.length + files.length > maxImages) {
                    alert(`Maximum ${maxImages} images allowed`);
                    return;
                }
                
                Array.from(files).forEach(file => {
                    if (!file.type.startsWith('image/')) {
                        alert('Only image files are allowed');
                        return;
                    }
                    
                    if (file.size > maxSize) {
                        alert(`Image ${file.name} is too large. Maximum size is 5MB`);
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.attachedImages.push({
                            name: file.name,
                            data: e.target.result,
                            size: file.size
                        });
                        this.updateImagePreview();
                    };
                    reader.readAsDataURL(file);
                });
            },
            
            updateImagePreview: function() {
                const preview = document.getElementById('adminTicketImagePreview');
                if (!preview) return;
                
                if (this.attachedImages.length === 0) {
                    preview.innerHTML = '';
                    return;
                }
                
                preview.innerHTML = this.attachedImages.map((img, index) => `
                    <div class="ticket-image-preview-item">
                        <img src="${img.data}" alt="${escapeHtml(img.name)}">
                        <button onclick="TicketSystemAdmin.removeImage(${index})">√ó</button>
                    </div>
                `).join('');
            },
            
            removeImage: function(index) {
                this.attachedImages.splice(index, 1);
                this.updateImagePreview();
            },
            
            clearImages: function() {
                this.attachedImages = [];
                this.updateImagePreview();
            },
            
            // Voice recording
            voiceRecording: null,
            mediaRecorder: null,
            audioChunks: [],
            isRecording: false,
            
            startRecording: async function() {
                if (this.isRecording) return;
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.audioChunks = [];
                    this.isRecording = true;
                    
                    const recordBtn = document.getElementById('adminTicketVoiceBtn');
                    if (recordBtn) {
                        recordBtn.classList.add('recording');
                    }
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.voiceRecording = {
                                data: e.target.result,
                                duration: 0
                            };
                            
                            if (recordBtn) {
                                recordBtn.classList.remove('recording');
                            }
                            
                            stream.getTracks().forEach(track => track.stop());
                        };
                        reader.readAsDataURL(audioBlob);
                    };
                    
                    this.mediaRecorder.start();
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not access microphone. Please check permissions.');
                    this.isRecording = false;
                }
            },
            
            stopRecording: function() {
                if (!this.isRecording || !this.mediaRecorder) return;
                
                if (this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                }
            },
            
            clearVoice: function() {
                this.voiceRecording = null;
            },
            
            playVoice: function(voiceId, audioData) {
                const btn = document.getElementById(voiceId + '_btn');
                const durationEl = document.getElementById(voiceId + '_duration');
                
                if (!btn || !audioData) return;
                
                const audio = new Audio(audioData);
                
                btn.innerHTML = `
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                `;
                btn.disabled = true;
                
                audio.addEventListener('loadedmetadata', () => {
                    if (durationEl) {
                        const duration = Math.round(audio.duration);
                        durationEl.textContent = `${duration}s`;
                    }
                });
                
                audio.addEventListener('ended', () => {
                    btn.innerHTML = `
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    `;
                    btn.disabled = false;
                });
                
                audio.play().catch(err => {
                    console.error('Error playing audio:', err);
                    btn.disabled = false;
                });
            },
            
            // Send message
            sendMessage: async function() {
                const input = this.getElement('adminTicketReplyInput');
                if (!input) return;
                
                const message = String(input.value || '').trim();
                const images = this.attachedImages;
                const voice = this.voiceRecording;
                
                if (!message && images.length === 0 && !voice) {
                    alert('Please enter a message, attach an image, or record a voice message');
                    return;
                }
                
                if (!this.currentTicketId) {
                    alert('No ticket selected');
                    return;
                }
                
                if (!window.firebaseInitialized || !window.database) {
                    alert('Firebase not initialized');
                    return;
                }
                
                const sendBtn = this.getElement('adminTicketSendBtn');
                try {
                    if (sendBtn) {
                        sendBtn.disabled = true;
                        sendBtn.textContent = 'Sending...';
                    }
                    
                    const messageData = {
                        ticketId: this.currentTicketId,
                        message: message || '',
                        sender: 'admin',
                        timestamp: Date.now(),
                        images: images.map(img => ({
                            name: img.name,
                            data: img.data
                        })),
                        voice: voice ? {
                            data: voice.data,
                            duration: voice.duration
                        } : null
                    };
                    
                    await window.database.ref(`ticketMessages/${this.currentTicketId}/${Date.now()}`).set(messageData);
                    await window.database.ref(`tickets/${this.currentTicketId}/updatedAt`).set(Date.now());
                    
                    input.value = '';
                    this.clearImages();
                    this.clearVoice();
                    await loadTickets(); // Refresh list
                } catch (error) {
                    console.error('Error sending message:', error);
                    alert('Failed to send message: ' + (error.message || 'Unknown error'));
                } finally {
                    if (sendBtn) {
                        sendBtn.disabled = false;
                        sendBtn.textContent = 'Send';
                    }
                }
            },
            
            // Toggle status
            toggleStatus: async function() {
                if (!this.currentTicketId) return;
                
                if (!confirm('Are you sure you want to change the ticket status?')) return;
                
                if (!window.firebaseInitialized || !window.database) {
                    alert('Firebase not initialized');
                    return;
                }
                
                try {
                    const snapshot = await window.database.ref(`tickets/${this.currentTicketId}`).once('value');
                    if (!snapshot.exists()) {
                        alert('Ticket not found');
                        return;
                    }
                    
                    const ticket = snapshot.val();
                    const newStatus = ticket.status === 'closed' ? 'open' : 'closed';
                    
                    await window.database.ref(`tickets/${this.currentTicketId}/status`).set(newStatus);
                    await window.database.ref(`tickets/${this.currentTicketId}/updatedAt`).set(Date.now());
                    
                    alert(`‚úÖ Ticket ${newStatus === 'closed' ? 'closed' : 'reopened'} successfully!`);
                    await loadTickets();
                    await this.view(this.currentTicketId); // Refresh view
                } catch (error) {
                    console.error('Error updating status:', error);
                    alert('Failed to update ticket: ' + (error.message || 'Unknown error'));
                }
            },
            
            // Delete ticket (using bracket notation for Firefox compatibility)
            'delete': async function(ticketId) {
                if (!ticketId) {
                    if (this.currentTicketId) {
                        ticketId = this.currentTicketId;
                    } else {
                        alert('No ticket selected');
                        return;
                    }
                }
                
                if (!confirm('Are you sure you want to delete this ticket? This action cannot be undone.')) {
                    return;
                }
                
                if (!window.firebaseInitialized || !window.database) {
                    alert('Firebase not initialized');
                    return;
                }
                
                try {
                    // Delete ticket
                    await window.database.ref(`tickets/${ticketId}`).remove();
                    
                    // Delete messages
                    await window.database.ref(`ticketMessages/${ticketId}`).remove();
                    
                    // Close modal if viewing this ticket
                    if (this.currentTicketId === ticketId) {
                        this.closeModal();
                    }
                    
                    // Refresh list
                    await loadTickets();
                    
                    alert('‚úÖ Ticket deleted successfully');
                } catch (error) {
                    console.error('Error deleting ticket:', error);
                    alert('Failed to delete ticket: ' + (error.message || 'Unknown error'));
                }
            },
            
            // Delete from modal
            deleteTicket: function() {
                if (this.currentTicketId) {
                    this['delete'](this.currentTicketId);
                }
            },
            
            // Save transcript
            saveTranscript: async function() {
                if (!this.currentTicketId) {
                    alert('No ticket selected');
                    return;
                }
                
                if (!window.firebaseInitialized || !window.database) {
                    alert('Firebase not initialized');
                    return;
                }
                
                try {
                    const ticketSnapshot = await window.database.ref(`tickets/${this.currentTicketId}`).once('value');
                    const messagesSnapshot = await window.database.ref(`ticketMessages/${this.currentTicketId}`).once('value');
                    
                    if (!ticketSnapshot.exists()) {
                        alert('Ticket not found');
                        return;
                    }
                    
                    const ticket = ticketSnapshot.val();
                    const messages = messagesSnapshot.exists() ? messagesSnapshot.val() : {};
                    const messagesArray = Object.entries(messages)
                        .map(([ts, msg]) => ({
                            timestamp: parseInt(ts) || Date.now(),
                            message: (msg && msg.message) ? String(msg.message) : '',
                            sender: (msg && msg.sender) ? String(msg.sender) : 'user'
                        }))
                        .filter(m => m.message)
                        .sort((a, b) => a.timestamp - b.timestamp);
                    
                    let transcript = `TICKET TRANSCRIPT\n`;
                    transcript += `==================\n\n`;
                    transcript += `Ticket ID: ${ticket.id || this.currentTicketId}\n`;
                    transcript += `Subject: ${ticket.subject || 'No subject'}\n`;
                    transcript += `Status: ${ticket.status || 'unknown'}\n`;
                    transcript += `User IP: ${ticket.userIp || 'Unknown'}\n`;
                    transcript += `Created: ${new Date(ticket.createdAt || Date.now()).toLocaleString()}\n`;
                    transcript += `Updated: ${new Date(ticket.updatedAt || Date.now()).toLocaleString()}\n\n`;
                    transcript += `MESSAGES\n`;
                    transcript += `========\n\n`;
                    
                    messagesArray.forEach(msg => {
                        const date = new Date(msg.timestamp);
                        transcript += `[${date.toLocaleString()}] ${msg.sender.toUpperCase()}: ${msg.message}\n\n`;
                    });
                    
                    const blob = new Blob([transcript], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ticket-${ticket.id || this.currentTicketId}-transcript.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    alert('‚úÖ Transcript saved successfully!');
                } catch (error) {
                    console.error('Error saving transcript:', error);
                    alert('Failed to save transcript: ' + (error.message || 'Unknown error'));
                }
            },
            
            // Close modal
            closeModal: function() {
                // Clean up listener
                if (this.messageListener && this.currentTicketId && window.database) {
                    try {
                        window.database.ref(`ticketMessages/${this.currentTicketId}`).off('value', this.messageListener);
                    } catch (e) {
                        console.warn('Error removing listener:', e);
                    }
                }
                
                this.currentTicketId = null;
                this.messageListener = null;
                
                const modal = this.getElement('adminTicketModal');
                if (modal) {
                    modal.classList.remove('active');
                }
                
                const input = this.getElement('adminTicketReplyInput');
                if (input) {
                    input.value = '';
                }
            }
        };
        
        // Global wrapper functions for onclick handlers
        window.viewAdminTicket = function(ticketId) {
            try {
                if (!ticketId) {
                    alert('Invalid ticket ID');
                    return;
                }
                if (!window.TicketSystemAdmin) {
                    alert('Ticket system not initialized. Please refresh the page.');
                    return;
                }
                window.TicketSystemAdmin.view(ticketId);
            } catch (error) {
                console.error('Error in viewAdminTicket:', error);
                alert('Error opening ticket: ' + (error.message || 'Unknown error'));
            }
        };
        
        window.deleteAdminTicket = function(ticketId) {
            try {
                if (!ticketId) {
                    alert('Invalid ticket ID');
                    return;
                }
                if (!window.TicketSystemAdmin) {
                    alert('Ticket system not initialized. Please refresh the page.');
                    return;
                }
                // Use bracket notation for Firefox compatibility
                window.TicketSystemAdmin['delete'](ticketId);
            } catch (error) {
                console.error('Error in deleteAdminTicket:', error);
                alert('Error deleting ticket: ' + (error.message || 'Unknown error'));
            }
        };
        
        window.closeAdminTicketModal = function() {
            if (window.TicketSystemAdmin) {
                window.TicketSystemAdmin.closeModal();
            }
        };
        
        window.sendAdminTicketMessage = function() {
            if (window.TicketSystemAdmin) {
                window.TicketSystemAdmin.sendMessage();
            }
        };
        
        window.closeAdminTicket = function() {
            if (window.TicketSystemAdmin) {
                window.TicketSystemAdmin.toggleStatus();
            }
        };
        
        window.saveTicketTranscript = function() {
            if (window.TicketSystemAdmin) {
                window.TicketSystemAdmin.saveTranscript();
            }
        };
        
        window.deleteAdminTicketFromModal = function() {
            if (window.TicketSystemAdmin) {
                // Use bracket notation for Firefox compatibility
                window.TicketSystemAdmin['delete'](window.TicketSystemAdmin.currentTicketId);
            }
        };
        
        // Setup image upload handler for admin
        function setupAdminImageHandler() {
            const adminImageInput = document.getElementById('adminTicketImageInput');
            if (adminImageInput) {
                adminImageInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) {
                        if (window.TicketSystemAdmin) {
                            window.TicketSystemAdmin.handleImageUpload(e.target.files);
                            e.target.value = ''; // Reset input
                        }
                    }
                });
            }
        }
        
        // Initialize image handler
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupAdminImageHandler);
        } else {
            setupAdminImageHandler();
        }
        
        // Image modal viewer
        window.openImageModal = function(imageSrc) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 20000; display: flex; align-items: center; justify-content: center; cursor: pointer;';
            modal.onclick = () => document.body.removeChild(modal);
            modal.innerHTML = `<img src="${escapeHtml(imageSrc)}" style="max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">`;
            document.body.appendChild(modal);
        };
        
        // Old ticket functions removed - using TicketSystemAdmin class above

        // ============================================
        // USER PROFILE MANAGEMENT
        // ============================================
        
        // Load user profiles
        async function loadUserProfiles() {
            const content = document.getElementById('profilesContent');
            if (!content) return;
            
            try {
                const searchInput = document.getElementById('profileSearchInput');
                const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
                
                const profilesSnapshot = await database.ref('userProfiles').once('value');
                if (!profilesSnapshot.exists()) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üë§</div><div class="empty-state-text">No user profiles yet</div></div>';
                    return;
                }
                
                const profiles = profilesSnapshot.val();
                const profilesArray = Object.entries(profiles)
                    .map(([id, profile]) => ({
                        id: id,
                        ...profile
                    }))
                    .filter(profile => {
                        if (!searchTerm) return true;
                        const username = (profile.username || '').toLowerCase();
                        const bio = (profile.bio || '').toLowerCase();
                        return username.includes(searchTerm) || bio.includes(searchTerm);
                    })
                    .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
                
                if (profilesArray.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üîç</div><div class="empty-state-text">No profiles found matching your search</div></div>';
                    return;
                }
                
                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>Avatar</th>
                                <th>Username</th>
                                <th>Bio</th>
                                <th>Created</th>
                                <th>Updated</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                profilesArray.forEach(profile => {
                    const avatarSrc = profile.avatar || `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2240%22 height=%2240%22%3E%3Ccircle cx=%2220%22 cy=%2220%22 r=%2220%22 fill=%22%233a3a3a%22/%3E%3Ctext x=%2220%22 y=%2225%22 font-size=%2216%22 fill=%22%23fff%22 text-anchor=%22middle%22%3E${encodeURIComponent((profile.username || '?').charAt(0).toUpperCase())}%3C/text%3E%3C/svg%3E`;
                    const createdDate = profile.createdAt ? new Date(profile.createdAt).toLocaleString() : 'Unknown';
                    const updatedDate = profile.updatedAt ? new Date(profile.updatedAt).toLocaleString() : 'Unknown';
                    const bio = (profile.bio || '').substring(0, 50) + ((profile.bio || '').length > 50 ? '...' : '');
                    
                    html += `
                        <tr>
                            <td>
                                <img src="${escapeHtml(avatarSrc)}" alt="${escapeHtml(profile.username || 'User')}" 
                                     style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid rgba(74, 74, 74, 0.5);"
                                     onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2240%22 height=%2240%22%3E%3Ccircle cx=%2220%22 cy=%2220%22 r=%2220%22 fill=%22%233a3a3a%22/%3E%3C/svg%3E'">
                            </td>
                            <td>${escapeHtml(profile.username || 'Unknown')}</td>
                            <td>${escapeHtml(bio || 'No bio')}</td>
                            <td>${createdDate}</td>
                            <td>${updatedDate}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="viewUserProfile('${escapeHtml(profile.id)}')">View</button>
                                    <button class="btn-action btn-edit" onclick="editUserProfile('${escapeHtml(profile.id)}')">Edit</button>
                                    <button class="btn-action btn-delete" onclick="deleteUserProfile('${escapeHtml(profile.id)}')">Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
                
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading profiles:', error);
                content.innerHTML = '<div style="color: #ef4444; padding: 20px;">Error loading profiles: ' + (error.message || 'Unknown error') + '</div>';
            }
        }
        
        // View user profile
        async function viewUserProfile(profileId) {
            try {
                const profileSnapshot = await database.ref(`userProfiles/${profileId}`).once('value');
                if (!profileSnapshot.exists()) {
                    alert('Profile not found');
                    return;
                }
                
                const profile = profileSnapshot.val();
                const avatarSrc = profile.avatar || `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22120%22 height=%22120%22%3E%3Ccircle cx=%2260%22 cy=%2260%22 r=%2260%22 fill=%22%233a3a3a%22/%3E%3Ctext x=%2260%22 y=%2275%22 font-size=%2240%22 fill=%22%23fff%22 text-anchor=%22middle%22%3E${encodeURIComponent((profile.username || '?').charAt(0).toUpperCase())}%3C/text%3E%3C/svg%3E`;
                const createdDate = profile.createdAt ? new Date(profile.createdAt).toLocaleString() : 'Unknown';
                const updatedDate = profile.updatedAt ? new Date(profile.updatedAt).toLocaleString() : 'Unknown';
                
                const modal = document.getElementById('userInfoModal');
                const content = document.getElementById('userInfoContent');
                
                if (modal && content) {
                    content.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <img src="${escapeHtml(avatarSrc)}" alt="${escapeHtml(profile.username || 'User')}" 
                                 style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover; border: 3px solid rgba(74, 74, 74, 0.5); margin-bottom: 16px;"
                                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22120%22 height=%22120%22%3E%3Ccircle cx=%2260%22 cy=%2260%22 r=%2260%22 fill=%22%233a3a3a%22/%3E%3C/svg%3E'">
                            <h3 style="margin: 0 0 8px 0; color: #e5e5e5;">${escapeHtml(profile.username || 'Unknown')}</h3>
                            <p style="color: #888; margin: 0;">User ID: ${escapeHtml(profileId)}</p>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <strong style="color: #c0c0c0;">Bio:</strong>
                            <p style="color: #e5e5e5; margin-top: 8px;">${escapeHtml(profile.bio || 'No bio provided')}</p>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <strong style="color: #c0c0c0;">Created:</strong>
                            <p style="color: #e5e5e5; margin-top: 8px;">${createdDate}</p>
                        </div>
                        <div style="margin-bottom: 16px;">
                            <strong style="color: #c0c0c0;">Last Updated:</strong>
                            <p style="color: #e5e5e5; margin-top: 8px;">${updatedDate}</p>
                        </div>
                    `;
                    modal.classList.add('active');
                }
            } catch (error) {
                console.error('Error viewing profile:', error);
                alert('Error loading profile: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Check if username is already taken (admin panel)
        async function isUsernameTakenAdmin(username, excludeUserId = null) {
            try {
                const profilesSnapshot = await database.ref('userProfiles').once('value');
                if (!profilesSnapshot.exists()) {
                    return false;
                }
                
                const profiles = profilesSnapshot.val();
                const usernameLower = username.toLowerCase().trim();
                
                for (const [userId, profile] of Object.entries(profiles)) {
                    // Skip the current user's profile if editing
                    if (excludeUserId && userId === excludeUserId) {
                        continue;
                    }
                    
                    const existingUsername = (profile.username || '').toLowerCase().trim();
                    if (existingUsername === usernameLower) {
                        return true;
                    }
                }
                
                return false;
            } catch (error) {
                console.error('Error checking username:', error);
                return false;
            }
        }
        
        // Edit user profile
        async function editUserProfile(profileId) {
            try {
                const profileSnapshot = await database.ref(`userProfiles/${profileId}`).once('value');
                if (!profileSnapshot.exists()) {
                    alert('Profile not found');
                    return;
                }
                
                const profile = profileSnapshot.val();
                const newUsername = prompt('Enter new username:', profile.username || '');
                if (newUsername === null) return;
                
                if (!newUsername.trim()) {
                    alert('Username cannot be empty');
                    return;
                }
                
                if (newUsername.length < 3) {
                    alert('Username must be at least 3 characters');
                    return;
                }
                
                // Check if username is already taken (case-insensitive)
                const usernameTaken = await isUsernameTakenAdmin(newUsername.trim(), profileId);
                if (usernameTaken) {
                    alert('This username is already taken. Please choose another one.');
                    return;
                }
                
                const newBio = prompt('Enter new bio (optional):', profile.bio || '');
                if (newBio === null) return;
                
                await database.ref(`userProfiles/${profileId}`).update({
                    username: newUsername.trim(),
                    bio: (newBio || '').trim(),
                    updatedAt: Date.now()
                });
                
                alert('‚úÖ Profile updated successfully!');
                loadUserProfiles();
            } catch (error) {
                console.error('Error editing profile:', error);
                alert('Error updating profile: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Delete user profile
        async function deleteUserProfile(profileId) {
            if (!confirm('Are you sure you want to delete this profile? This action cannot be undone.')) {
                return;
            }
            
            try {
                await database.ref(`userProfiles/${profileId}`).remove();
                alert('‚úÖ Profile deleted successfully!');
                loadUserProfiles();
            } catch (error) {
                console.error('Error deleting profile:', error);
                alert('Error deleting profile: ' + (error.message || 'Unknown error'));
            }
        }

        // ============================================
        // GRANTED ACCESS SYSTEM
        // ============================================
        const GRANTED_ACCESS_PATH = 'admin/grantedAccess';
        const LICENSE_KEYS_PATH = 'admin/licenseKeys';
        let selectedGrantUserId = null;

        // Check if user has granted access
        async function checkGrantedAccess() {
            if (!window.firebaseInitialized || !window.database) return false;
            try {
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                if (!userProfileId) return false;

                const grantedSnapshot = await window.database.ref(`${GRANTED_ACCESS_PATH}/${userProfileId}`).once('value');
                return grantedSnapshot.exists();
            } catch (error) {
                console.error('Error checking granted access:', error);
                return false;
            }
        }

        // Get user's access level
        async function getUserAccessLevel() {
            if (!window.firebaseInitialized || !window.database) return null;
            try {
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                if (!userProfileId) return null;

                // Check if full admin
                if (ALLOWED_ADMIN_USER_IDS.includes(userProfileId)) {
                    return { level: 'full', canGrant: true };
                }

                // Check if granted access
                const grantedSnapshot = await window.database.ref(`${GRANTED_ACCESS_PATH}/${userProfileId}`).once('value');
                if (grantedSnapshot.exists()) {
                    const access = grantedSnapshot.val();
                    return {
                        level: 'granted',
                        canGrant: access.canGrant || false
                    };
                }

                return null;
            } catch (error) {
                console.error('Error getting user access level:', error);
                return null;
            }
        }

        // Load personal license keys for granted users
        async function loadPersonalLicenseKeys() {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                if (!userProfileId) {
                    document.getElementById('keysContent').innerHTML = '<div class="empty-state"><div class="empty-state-text">Please log in to view your license keys.</div></div>';
                    return;
                }

                const keysSnapshot = await window.database.ref(`${LICENSE_KEYS_PATH}/${userProfileId}`).once('value');
                const keys = keysSnapshot.exists() ? keysSnapshot.val() : {};
                const content = document.getElementById('keysContent');
                if (!content) return;

                const searchQuery = document.getElementById('keySearchInput')?.value.toLowerCase() || '';

                // Convert to array and filter
                let keysArray = Object.entries(keys).map(([keyId, keyData]) => ({
                    id: keyId,
                    key: keyData.key || keyId,
                    createdAt: keyData.createdAt || Date.now()
                }));

                // Filter by search
                if (searchQuery) {
                    keysArray = keysArray.filter(k => k.key.toLowerCase().includes(searchQuery));
                }

                if (keysArray.length === 0) {
                    content.innerHTML = '<div class="empty-state"><div class="empty-state-text">No license keys yet. Add your first key!</div></div>';
                    return;
                }

                // Sort by creation date (newest first)
                keysArray.sort((a, b) => b.createdAt - a.createdAt);

                let html = `
                    <table class="admin-table">
                        <thead>
                            <tr>
                                <th>License Key</th>
                                <th>Created</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                keysArray.forEach(keyData => {
                    const createdDate = new Date(keyData.createdAt).toLocaleDateString();
                    html += `
                        <tr>
                            <td style="font-family: monospace; font-size: 12px; word-break: break-all;">${escapeHtml(keyData.key)}</td>
                            <td>${createdDate}</td>
                            <td>
                                <div class="action-buttons">
                                    <button class="btn-action btn-view" onclick="copyKey('${escapeHtml(keyData.key)}')" title="Copy Key">üìã</button>
                                    <button class="btn-action btn-delete" onclick="deletePersonalLicenseKey('${userProfileId}', '${keyData.id}')" style="background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.3); color: #ef4444;" title="Delete Key">üóëÔ∏è</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                content.innerHTML = html;
            } catch (error) {
                console.error('Error loading personal license keys:', error);
                document.getElementById('keysContent').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-text">Error loading license keys: ${escapeHtml(error.message || 'Unknown error')}</div>
                        <button class="admin-btn" onclick="loadKeys()" style="margin-top: 16px;">Retry</button>
                    </div>
                `;
            }
        }

        // Add personal license key
        async function addPersonalLicenseKey() {
            const key = prompt('Enter license key:');
            if (!key || !key.trim()) return;

            if (!window.firebaseInitialized || !window.database) {
                alert('Error: Database not available. Please try again.');
                return;
            }

            try {
                const userProfileId = localStorage.getItem(USER_PROFILE_ID_KEY);
                if (!userProfileId) {
                    alert('Please log in first.');
                    return;
                }

                const keyId = `key_${Date.now()}`;
                await window.database.ref(`${LICENSE_KEYS_PATH}/${userProfileId}/${keyId}`).set({
                    key: key.trim(),
                    createdAt: Date.now()
                });

                await loadPersonalLicenseKeys();
                alert('‚úÖ License key added successfully!');
            } catch (error) {
                console.error('Error adding license key:', error);
                alert('‚ùå Error adding license key. Please try again.');
            }
        }

        // Delete personal license key
        window.deletePersonalLicenseKey = async function(userId, keyId) {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                const currentUserId = localStorage.getItem(USER_PROFILE_ID_KEY);
                if (currentUserId !== userId) {
                    alert('You can only delete your own license keys.');
                    return;
                }

                if (confirm('Are you sure you want to delete this license key?')) {
                    await window.database.ref(`${LICENSE_KEYS_PATH}/${userId}/${keyId}`).remove();
                    await loadPersonalLicenseKeys();
                    alert('‚úÖ License key deleted successfully!');
                }
            } catch (error) {
                console.error('Error deleting license key:', error);
                alert('‚ùå Error deleting license key. Please try again.');
            }
        };

        // Load Final Reseller
        async function loadFinalReseller() {
            const content = document.getElementById('finalResellerContent');
            if (content) {
                content.innerHTML = '<div style="color: #888; padding: 20px; text-align: center;">Final Reseller management interface coming soon.</div>';
            }
        }

        // Load users for Grant tab
        async function loadUsersForGrant() {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                const usersSnapshot = await window.database.ref('userProfiles').once('value');
                const users = usersSnapshot.exists() ? usersSnapshot.val() : {};
                const userList = document.getElementById('grantUserList');
                if (!userList) return;

                userList.innerHTML = '';
                const searchInput = document.getElementById('grantUserSearch');
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

                Object.entries(users).forEach(([userId, userData]) => {
                    const username = (userData.username || 'Unknown').toLowerCase();
                    if (searchTerm && !username.includes(searchTerm) && !userId.includes(searchTerm)) {
                        return;
                    }

                    const userItem = document.createElement('div');
                    userItem.style.cssText = 'padding: 15px; margin-bottom: 10px; background: rgba(26, 26, 26, 0.5); border: 1px solid rgba(74, 74, 74, 0.3); border-radius: 4px; cursor: pointer; transition: all 0.2s;';
                    userItem.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 40px; height: 40px; border-radius: 50%; background: #1a1a1a; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                                ${userData.avatar ? `<img src="${userData.avatar}" style="width: 100%; height: 100%; object-fit: cover;">` : `<span style="color: #fff; font-size: 18px;">${(userData.username || '?').charAt(0).toUpperCase()}</span>`}
                            </div>
                            <div>
                                <div style="color: #e5e5e5; font-weight: 500;">${escapeHtml(userData.username || 'Unknown')}</div>
                                <div style="color: #888; font-size: 12px;">${escapeHtml(userId)}</div>
                            </div>
                        </div>
                    `;
                    userItem.addEventListener('click', () => selectUserForGrant(userId, userData));
                    userItem.addEventListener('mouseenter', () => {
                        userItem.style.background = 'rgba(26, 26, 26, 0.8)';
                        userItem.style.borderColor = 'rgba(59, 130, 246, 0.5)';
                    });
                    userItem.addEventListener('mouseleave', () => {
                        userItem.style.background = 'rgba(26, 26, 26, 0.5)';
                        userItem.style.borderColor = 'rgba(74, 74, 74, 0.3)';
                    });
                    userList.appendChild(userItem);
                });
            } catch (error) {
                console.error('Error loading users for grant:', error);
            }
        }

        // Select user for grant
        function selectUserForGrant(userId, userData) {
            selectedGrantUserId = userId;
            const selectedDiv = document.getElementById('grantSelectedUser');
            const selectedInfo = document.getElementById('grantSelectedUserInfo');
            if (selectedDiv && selectedInfo) {
                selectedDiv.style.display = 'block';
                selectedInfo.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <div style="width: 50px; height: 50px; border-radius: 50%; background: #1a1a1a; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                            ${userData.avatar ? `<img src="${userData.avatar}" style="width: 100%; height: 100%; object-fit: cover;">` : `<span style="color: #fff; font-size: 24px;">${(userData.username || '?').charAt(0).toUpperCase()}</span>`}
                        </div>
                        <div>
                            <div style="color: #e5e5e5; font-weight: 500; font-size: 16px;">${escapeHtml(userData.username || 'Unknown')}</div>
                            <div style="color: #888; font-size: 12px;">${escapeHtml(userId)}</div>
                        </div>
                    </div>
                `;
            }
        }

        // Grant access to user
        async function grantUserAccess() {
            if (!window.firebaseInitialized || !window.database || !selectedGrantUserId) {
                alert('Please select a user first.');
                return;
            }
            try {
                const canGrant = document.getElementById('grantAccessToGrantTab')?.checked || false;
                const currentUserId = localStorage.getItem(USER_PROFILE_ID_KEY);

                await window.database.ref(`${GRANTED_ACCESS_PATH}/${selectedGrantUserId}`).set({
                    grantedBy: currentUserId,
                    grantedAt: Date.now(),
                    canGrant: canGrant,
                    accessLevel: 'licenseKeys'
                });

                // Initialize empty license keys for this user
                await window.database.ref(`${LICENSE_KEYS_PATH}/${selectedGrantUserId}`).set({});

                alert('‚úÖ Access granted successfully!');
                selectedGrantUserId = null;
                document.getElementById('grantSelectedUser').style.display = 'none';
                await loadGrantedUsers();
            } catch (error) {
                console.error('Error granting access:', error);
                alert('‚ùå Error granting access. Please try again.');
            }
        }

        // Revoke access from user
        async function revokeUserAccess() {
            if (!window.firebaseInitialized || !window.database || !selectedGrantUserId) {
                alert('Please select a user first.');
                return;
            }
            try {
                if (confirm('Are you sure you want to revoke access for this user?')) {
                    await window.database.ref(`${GRANTED_ACCESS_PATH}/${selectedGrantUserId}`).remove();
                    alert('‚úÖ Access revoked successfully!');
                    selectedGrantUserId = null;
                    document.getElementById('grantSelectedUser').style.display = 'none';
                    await loadGrantedUsers();
                }
            } catch (error) {
                console.error('Error revoking access:', error);
                alert('‚ùå Error revoking access. Please try again.');
            }
        }

        // Load granted users list
        async function loadGrantedUsers() {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                const grantedSnapshot = await window.database.ref(GRANTED_ACCESS_PATH).once('value');
                const granted = grantedSnapshot.exists() ? grantedSnapshot.val() : {};
                const list = document.getElementById('grantedUsersList');
                if (!list) return;

                list.innerHTML = '';
                if (Object.keys(granted).length === 0) {
                    list.innerHTML = '<div style="color: #888; padding: 20px; text-align: center;">No users have been granted access yet.</div>';
                    return;
                }

                // Load user profiles
                const usersSnapshot = await window.database.ref('userProfiles').once('value');
                const users = usersSnapshot.exists() ? usersSnapshot.val() : {};

                Object.entries(granted).forEach(([userId, accessData]) => {
                    const userData = users[userId] || {};
                    const item = document.createElement('div');
                    item.style.cssText = 'padding: 15px; margin-bottom: 10px; background: rgba(26, 26, 26, 0.5); border: 1px solid rgba(74, 74, 74, 0.3); border-radius: 4px;';
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background: #1a1a1a; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                                    ${userData.avatar ? `<img src="${userData.avatar}" style="width: 100%; height: 100%; object-fit: cover;">` : `<span style="color: #fff;">${(userData.username || '?').charAt(0).toUpperCase()}</span>`}
                                </div>
                                <div>
                                    <div style="color: #e5e5e5; font-weight: 500;">${escapeHtml(userData.username || 'Unknown')}</div>
                                    <div style="color: #888; font-size: 12px;">${accessData.canGrant ? 'Can grant access' : 'License Keys only'} ‚Ä¢ Granted ${new Date(accessData.grantedAt).toLocaleDateString()}</div>
                                </div>
                            </div>
                            <button class="admin-btn" style="background: #ef4444; padding: 8px 16px; font-size: 12px;" onclick="revokeAccessById('${userId}')">Revoke</button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading granted users:', error);
            }
        }

        // Revoke access by ID
        window.revokeAccessById = async function(userId) {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                if (confirm('Are you sure you want to revoke access for this user?')) {
                    await window.database.ref(`${GRANTED_ACCESS_PATH}/${userId}`).remove();
                    await loadGrantedUsers();
                    alert('‚úÖ Access revoked successfully!');
                }
            } catch (error) {
                console.error('Error revoking access:', error);
                alert('‚ùå Error revoking access. Please try again.');
            }
        };

        // Load Owner Management
        async function loadOwnerManagement() {
            if (!window.firebaseInitialized || !window.database) return;
            const list = document.getElementById('ownerManagementList');
            if (!list) return;

            try {
                // Search for users by username
                const usersSnapshot = await window.database.ref('userProfiles').once('value');
                const users = usersSnapshot.exists() ? usersSnapshot.val() : {};
                
                const ownerNames = ['Aiden', 'Yyy'];
                const foundOwners = [];

                // Find users matching owner names
                Object.entries(users).forEach(([userId, userData]) => {
                    const username = (userData.username || '').toLowerCase();
                    ownerNames.forEach(ownerName => {
                        if (username === ownerName.toLowerCase()) {
                            foundOwners.push({ userId, username: userData.username || ownerName, name: ownerName });
                        }
                    });
                });

                list.innerHTML = '';
                if (foundOwners.length === 0) {
                    list.innerHTML = '<div style="color: #888; padding: 20px; text-align: center;">No matching users found. Make sure Aiden and Yyy have created profiles.</div>';
                    return;
                }

                foundOwners.forEach(owner => {
                    const item = document.createElement('div');
                    item.style.cssText = 'padding: 15px; margin-bottom: 10px; background: rgba(26, 26, 26, 0.5); border: 1px solid rgba(74, 74, 74, 0.3); border-radius: 4px;';
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="color: #e5e5e5; font-weight: 500; font-size: 16px;">${escapeHtml(owner.username)}</div>
                                <div style="color: #888; font-size: 12px;">${escapeHtml(owner.userId)}</div>
                            </div>
                            <button class="admin-btn" style="background: #ef4444; padding: 8px 16px;" onclick="removeOwnerAccess('${owner.userId}', '${escapeHtml(owner.username)}')">Remove Admin Access</button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            } catch (error) {
                console.error('Error loading owner management:', error);
                list.innerHTML = '<div style="color: #ef4444; padding: 20px; text-align: center;">Error loading owner management.</div>';
            }
        }

        // Remove owner access
        window.removeOwnerAccess = async function(userId, username) {
            if (!window.firebaseInitialized || !window.database) return;
            try {
                if (confirm(`Are you sure you want to remove admin access for ${username}?`)) {
                    // Remove from granted access if exists
                    await window.database.ref(`${GRANTED_ACCESS_PATH}/${userId}`).remove();
                    
                    // Also mark as removed owner
                    await window.database.ref(`admin/removedOwners/${userId}`).set({
                        removedAt: Date.now(),
                        removedBy: localStorage.getItem(USER_PROFILE_ID_KEY),
                        username: username
                    });
                    
                    alert('‚úÖ Admin access removed successfully!');
                    await loadOwnerManagement();
                }
            } catch (error) {
                console.error('Error removing owner access:', error);
                alert('‚ùå Error removing access. Please try again.');
            }
        };
    </script>
</body>
</html>

